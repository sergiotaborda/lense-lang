unit = moduleDeclaration | packageDeclaration |  importDeclarations?, typeDeclarations;
	imutabilityModifier = 'var' | 'val';
	visibilityModifier = 'public' | 'private' | 'protected';
	varianceModifier = 'in' | 'out' | 'inv' | empty;
	implementationModifiers = implementationModifier | implementationModifiers, implementationModifier;
	implementationModifier = 'abstract' | 'native' | 'sealed';
	annotations = annotation | annotations , annotation;
	annotation = '@', identifier;
	moduleDeclaration = 'module' , qualifiedName, '(', versionLiteral, ')',  moduleBody ;
		moduleBody = '{', '}' | '{' , moduleMemberDeclarations , '}';
		moduleMemberDeclarations = moduleMemberDeclaration | moduleMemberDeclarations, moduleMemberDeclaration;
		moduleMemberDeclaration = moduleImport | moduleExport;
		moduleImport = 'import' , qualifiedName , versionMatchLiteral, ';';
		versionMatchLiteral = versionLiteral | versionLiteral , '+' ;
		moduleExport = 'export' , qualifiedName , '.' , '*', ';' | 'export' , qualifiedName , ';';
packageDeclaration  = 'package' , qualifiedName , ';' ;
	qualifiedName = identifier | qualifiedName , '.' , identifier; 
importDeclarations = importDeclaration | importDeclarations , importDeclaration;
	importDeclaration = 'import' , qualifiedName , ';' | 'import' , qualifiedName  ,'as', identifier, ';' | 'import' , qualifiedName , '{' , importTypes, '}';
	importTypes = importName | importTypes , ',' , importName;
	importName = identifier | identifier, 'as', identifier ;
typeDeclarations = typeDeclaration | typeDeclarations ,  typeDeclaration;
	typeDeclaration = classDeclaration | interfaceDeclaration | objectDeclaration;
	classDeclaration = annotations?, visibilityModifier?, implementationModifiers? , 'class', qualifiedName, genericTypesDeclaration, superDeclaration, implementsInterfaces?,  classBody;
	objectDeclaration = annotations?, visibilityModifier?, implementationModifiers? , 'object', qualifiedName, superDeclaration, implementsInterfaces?,  classBody;
		implementsInterfaces = 'implements', extendsInterfaceType;
	interfaceDeclaration = annotations?, visibilityModifier?, 'interface', qualifiedName, genericTypesDeclaration, extendsInterfaces? , interfaceBody;
		extendsInterfaces = 'extends', extendsInterfaceType;
		extendsInterfaceType = type | extendsInterfaceType, ',', type;
		interfaceBody= '{', interfaceMemberDeclarations ,'}' | '{' , '}';
		interfaceMemberDeclarations= interfaceMemberDeclaration | interfaceMemberDeclarations , interfaceMemberDeclaration;
		interfaceMemberDeclaration= abstractMethodDeclaration | abstractPropertyDeclaration | abstractIndexerDeclaration;
			abstractPropertyDeclaration = annotations?, imutabilityModifier? , visibilityModifier?, identifier , ':' , type , abstractPropertyHead ;
			abstractPropertyHead = '{' , '}' | '{' ,  abstractPropertyMembers , '}';
			abstractPropertyMembers = abstractPropertyMember | abstractPropertyMembers, abstractPropertyMember;
			abstractPropertyMember =  annotations?, visibilityModifier?,'set', ';' | annotations?, visibilityModifier?, 'get', ';';
			abstractMethodDeclaration = annotations?, visibilityModifier?, implementationModifiers? , identifier ,'(', formalParameterList , ')' , ':',  type , ';' | annotations?, visibilityModifier?, implementationModifiers? ,  identifier ,'(', ')' , ':' , type , ';' ;
	genericTypesDeclaration = empty | '<' , parametricTypes , '>';
	superDeclaration = empty | 'extends' , type;
	classBody = '{',classBodyDeclarations ,'}' | '{' ,'}';
		classBodyDeclarations = classBodyDeclaration | classBodyDeclarations, classBodyDeclaration;
			classBodyDeclaration = classMemberDeclaration;
		constructorDeclaration = annotations?, visibilityModifier?, implementationModifiers?, constructorDeclarator, '(', constructorFormalParameterList?, ')',  construtorBlock;
			constructorFormalParameterList = constructorFormalParameter | constructorFormalParameterList, ',' , constructorFormalParameter;
			constructorFormalParameter =  visibilityModifier? , imutabilityModifier?,  variableName, ':' , type ; 
			construtorBlock = ';' | block;
			constructorDeclarator = 'constructor'  | 'constructor', identifier | 'implicit', 'constructor'  | 'implicit', 'constructor', identifier;
		classMemberDeclaration = fieldDeclaration | methodDeclaration | constructorDeclaration | propertyDeclaration | indexerDeclaration | abstractIndexerDeclaration;
			fieldDeclaration =  annotations?,  visibilityModifier?, imutabilityModifier , variableName, ':' , type , ';' | annotations?,  visibilityModifier?, imutabilityModifier , variableName, '=' , expression , ';' | annotations?, visibilityModifier?, imutabilityModifier , variableName, ':', type,  '=' , expression , ';' ;
			propertyDeclaration =  typedPropertyDeclaration | nonTypedPropertyDeclaration;
				typedPropertyDeclaration =  annotations?, visibilityModifier?, implementationModifiers? , identifier, ':', type,  propertyDeclarationHead | annotations?,  visibilityModifier?, implementationModifiers? , identifier, ':', type,  propertyDeclarationHead , '=', expression, ';' ;
				nonTypedPropertyDeclaration =  annotations?, visibilityModifier?, implementationModifiers? , identifier, propertyDeclarationHead | annotations?, visibilityModifier?, implementationModifiers? , identifier, propertyDeclarationHead , '=', expression, ';' ;
					propertyDeclarationHead = '{' , '}' | '{' , propertyMembers, '}';
					propertyMembers = propertyMember | propertyMembers , propertyMember;
						propertyMember = annotations?,visibilityModifier?, 'get', ';' | annotations?, visibilityModifier?, 'get', '{' , blockStatements , '}' | annotations?, visibilityModifier?, 'set', ';' | annotations?, visibilityModifier?, 'set', '(', identifier, ')', '{' , blockStatements , '}';
					indexerDeclaration = annotations?, visibilityModifier?, implementationModifiers? ,  '[' , formalParameterList , ']' , ':' , type , propertyDeclarationHead;
					abstractIndexerDeclaration = annotations?, visibilityModifier?, implementationModifiers? ,  '[' , formalParameterList , ']' , ':' , type , abstractPropertyHead;
type = nonNullType | nonNullType , '?' ;
nonNullType = identifier | identifier , '<' , parametricTypes , '>' | '(' , tupleTypes , ')';
tupleTypes = type | tupleTypes , ',' , type;
parametricTypes = parametricType | parametricTypes , ',', parametricType;
	parametricType = varianceModifier , type;
variableName = identifier;
methodDeclaration= methodHeader ,':', type , methodBody | methodHeader, ':', type , ';' | methodHeader ,':', type , '=>', expression , ';' |  methodHeader , '{' , blockStatements , '}' | methodHeader , '=>', expression , ';';
	methodHeader = annotations?, visibilityModifier?, implementationModifiers? , identifier ,'(', formalParameterList , ')' | annotations?, visibilityModifier?, implementationModifiers? , identifier ,'(', ')'; 
	methodBody = block ;
block =  '{' , '}' | '{' , blockStatements , '}';
formalParameterList = formalParameter | formalParameterList, ',', formalParameter;
	formalParameter =  variableName, ':' , type;
blockStatements = blockStatement | blockStatements, blockStatement;
	blockStatement = localVariableDeclarationStatement | statement;
		localVariableDeclarationStatement = imutabilityModifier , variableName, ':' , type, ';' | imutabilityModifier , variableName , '=' , expression, ';' | imutabilityModifier , variableName, ':', type , '=' , expression, ';' ;
		statement= expressionStatement | whileStatement | forStatement | ifThenStatement | switchStatement | returnStatement | breakStatement | continueStatement | tryStatement | throwsStatement;
			returnStatement =  'return', expression, ';' |  'return', ';';
			throwsStatement = 'throw', expression, ';' ;
			breakStatement = 'break', identifier, ';' | 'break', ';' ;
			continueStatement= 'continue', identifier, ';' | 'continue', ';';
			tryStatement= 'try', resource?, block, catches?, finally?;
			resource = '(' , assignment, ')';
					assignment = leftHandSide, assignmentOperator, expression; 
					assignmentOperator = '=' |'*=' | '/=' |'%=' |'-=' |'+=' | '<<=' |'>>=' | '>>>=' | '&=' | '^=' | '|=';
					leftHandSide = fieldAccess | arrayAccess;
			catches = catchClause | catches , catchClause;
			catchClause= 'catch', '(', formalParameter ,')', block;
			finally = 'finally', block;
			expressionStatement= statementExpression , ';';
				statementExpression= assignment | postincrementExpression  | postdecrementExpression | methodInvocation | classInstanceCreationExpression;
			whileStatement= 'while', '(', expression, ')',  block | 'while', '(', expression, ')';
			forStatement= 'for',  '(', iterationType , 'in', expression ,')', block;
				iterationType = variableName  | 'val' , variableName;
			ifThenStatement = 'if', '(', expression ,')', block | 'if', '(', expression ,')', block , 'else', elseOptions;
				elseOptions =  block | ifThenStatement ;
			switchStatement = 'switch', '(', constantExpression, ')', switchBlock;
				switchBlock = '{', switchLabels, '}';
				switchLabels= switchLabel | switchLabels, switchLabel;
				switchLabel = 'case', '(',  expression , ')' , block | 'default' , block;
			constantExpression= leftHandSide;
			expression = variableName | lambdaExpression | assignment;
			lambdaExpression = lambda | conditionalExpression;
				lambda = '(' , lambdaParameters , ')' , '->', expression |  variableName , '->', expression |  '(' , ')' , '->', expression;
				lambdaParameters = formalParameterList | variableNamesList;
					variableNamesList = variableName | variableNamesList, ',', variableName;
			conditionalExpression= conditionalOrExpression | ternaryExpression;
			ternaryExpression = conditionalOrExpression, '?', expression, ':', expression;
			conditionalOrExpression = conditionalAndExpression | conditionalOrExpression ,'||', conditionalAndExpression;
			conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression, '&&', inclusiveOrExpression;
			inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression , '|', exclusiveOrExpression;
			exclusiveOrExpression = andExpression | exclusiveOrExpression, '^', andExpression;
			andExpression = equalityExpression | andExpression, '&', equalityExpression;
			equalityExpression = relationalExpression | equalityExpression, equalityOperator, relationalExpression;
			equalityOperator = '==' | '!=' | '===' | '!==' | '<=>';
			relationalExpression = shiftExpression | relationalExpression, compareOperator, shiftExpression | relationalExpression, 'is', typeObject;
				typeObject = identifier;
			compareOperator = '<' | '>' | '<=' | '>=';
			shiftExpression = additiveExpression | shiftExpression, shiftOperator, additiveExpression;
			shiftOperator = '<<' | '>>' | '>>>';
			additiveExpression = multiplicativeExpression | additiveExpression, '+', multiplicativeExpression | additiveExpression, '-', multiplicativeExpression;
			multiplicativeExpression = rangeExpression |  multiplicativeExpression ,multiplicativeOperator, rangeExpression;
			multiplicativeOperator = '*' | '/' | '%';
			rangeExpression = unaryExpression | unaryExpression , '..', unaryExpression | intervalStart , unaryExpression , ',', unaryExpression, intervalEnd | '|(' , '*' , ',', unaryExpression, intervalEnd | intervalStart , unaryExpression , ',', '*', ')|'  ; 
			intervalStart = '|[' | '|(';
			intervalEnd = ')|' | ']|' ;
			unaryExpression = unaryExpressionNotPlusMinus | unaryAditiveOperator, unaryExpression;
			unaryAditiveOperator = '+' | '-'| '++' |'--';
			unaryExpressionNotPlusMinus = postfixExpression | unaryMultiplicativeOperator, unaryExpression;
			unaryMultiplicativeOperator = '~' | '!' ;
			postfixExpression = primary | postincrementExpression  | postdecrementExpression;
				postincrementExpression = postfixExpression, '++';
				postdecrementExpression = postfixExpression, '--';
				primary = literal | 'this' | 'super' | '(', expression ,')' | classInstanceCreationExpression | fieldAccess | arrayAccess | methodInvocation;
					fieldAccess= primary ,'.', identifier | identifier;
					arrayAccess = primary ,'[', argumentList, ']' | primary, '[', argumentList, ']';
					classInstanceCreationExpression = 'new' ,type, '(', argumentList, ')' | 'new' ,type, '(', ')' | 'new' ,type, '.' , identifier, '(', argumentList, ')' | 'new' ,type,  '.' , identifier, '(', ')';
						argumentList = expression | argumentList, ',', expression;
					methodInvocation= primary ,'.', identifier , '(', argumentList? ,')' | identifier , '(', argumentList? ,')';
					literal= numberLiteral | booleanLiteral | stringLiteral | nullLiteral | noneLiteral | arrayInitializer | tupleInitializer | mapInitializer;
						arrayInitializer = '[' , arrayInitializerVariables , ']';
							arrayInitializerVariables = expression | arrayInitializerVariables , ',' , expression;
						tupleInitializer = '(' , tupleInitializerVariables , ')' | '(' , ')';
							tupleInitializerVariables = expression | tupleInitializerVariables , ',' , expression;
						mapInitializer = '{' , mapInitializerVariables , '}';
							mapInitializerVariables = mapInitializerPair | mapInitializerVariables, ',' , mapInitializerPair;
							mapInitializerPair = expression , ':' , expression;
					numberLiteral = number;
					booleanLiteral= 'true' | 'false';
					stringLiteral = text;
					nullLiteral = 'null';
					noneLiteral = 'none';