unit = moduleDeclaration | packageDeclaration?,  importDeclarations?, typeDeclarations;
	imutabilityModifier =  'mutable' | empty ;
	visibilityModifier = 'public' | 'private' | 'protected';
	varianceModifier = 'in' | 'out' | 'inv' | empty;
	implementationModifiers = implementationModifier | implementationModifiers, implementationModifier;
	implementationModifier = 'abstract' | 'native' | 'sealed' | 'final' | 'override' | 'default' | 'value' | 'mutable';
	annotations = annotation | annotations , annotation;
	annotation = '@', identifier;
	moduleDeclaration = 'module' , qualifiedName, '(', versionLiteral, ')',  moduleBody ;
		moduleBody = '{', '}' | '{' , moduleMemberDeclarations , '}';
		moduleMemberDeclarations = moduleMemberDeclaration | moduleMemberDeclarations, moduleMemberDeclaration;
		moduleMemberDeclaration = moduleImport | moduleExport;
		moduleImport = 'import' , qualifiedName , versionMatchLiteral, ';';
		versionMatchLiteral = versionLiteral | versionLiteral , '+' ;
		moduleExport = 'export' , qualifiedName , '.' , '*', ';' | 'export' , qualifiedName , ';';
packageDeclaration  = 'package' , qualifiedName , ';' ;
	qualifiedName = identifier | qualifiedName , '.' , identifier; 
importDeclarations = importDeclaration | importDeclarations , importDeclaration;
	importDeclaration = 'import' , qualifiedName , ';' | 'import' , qualifiedName  ,'as', identifier, ';' | 'import' , qualifiedName , '{' , importTypes, '}';
	importTypes = importName | importTypes , ',' , importName;
	importName = identifier | identifier, 'as', identifier ;
typeDeclarations = typeDeclaration | typeDeclarations ,  typeDeclaration;
	typeDeclaration = classDeclaration | interfaceDeclaration | objectDeclaration | enhancementDeclaration;
	enhancementDeclaration = annotations?, visibilityModifier?, 'enhancement' , qualifiedName , genericTypesDeclaration,  'extends' , type, genericTypesDeclaration , enhancementBody;
		enhancementBody = '{',enhancementBodyDeclarations ,'}';
		enhancementBodyDeclarations = enhancementBodyDeclaration | enhancementBodyDeclarations, enhancementBodyDeclaration;
			enhancementBodyDeclaration = enhancementMemberDeclaration;
			enhancementMemberDeclaration = constructorDeclaration | methodDeclaration;
	classDeclaration = annotations?, visibilityModifier?, implementationModifiers? , 'class', qualifiedName, genericTypesDeclaration, sealedDeclaration?, superDeclaration?, implementsInterfaces?,  classBody;
		sealedDeclaration = 'is' , sealedChildTypes;
		sealedChildTypes = sealedChildType | sealedChildTypes , ',' , sealedChildType;
		sealedChildType = booleanLiteral | noneLiteral | nonNullType;
		superDeclaration =  'extends' , type;
		implementsInterfaces = 'implements', extendsInterfaceType;
	objectDeclaration = annotations?, visibilityModifier?, implementationModifiers? , 'object', qualifiedName, sealedDeclaration?, superDeclaration?, implementsInterfaces?,  classBody;
	interfaceDeclaration = annotations?, visibilityModifier?, 'interface', qualifiedName, genericTypesDeclaration, sealedDeclaration?, extendsInterfaces? , interfaceBody;
		extendsInterfaces = 'extends', extendsInterfaceType;
		extendsInterfaceType = nonNullType | extendsInterfaceType, ',', nonNullType;
		interfaceBody= '{', interfaceMemberDeclarations ,'}' | '{' , '}';
		interfaceMemberDeclarations= interfaceMemberDeclaration | interfaceMemberDeclarations , interfaceMemberDeclaration;
		interfaceMemberDeclaration= constructorDeclaration | abstractMethodDeclaration | abstractPropertyDeclaration | abstractIndexerDeclaration;
			abstractPropertyDeclaration = annotations?,  visibilityModifier?, imutabilityModifier? , identifier , ':' , type , abstractPropertyHead ;
			abstractPropertyHead = '{' ,  abstractPropertyMembers , '}' | ';';
			abstractPropertyMembers = abstractPropertyMember | abstractPropertyMembers, abstractPropertyMember;
			abstractPropertyMember =  annotations?, visibilityModifier?,'set', ';' | annotations?, visibilityModifier?, 'get', ';';
			abstractMethodDeclaration = annotations?, visibilityModifier?, implementationModifiers? , identifier , genericTypesDeclaration, '(', formalParameterList , ')' , ':',  type , ';' | annotations?, visibilityModifier?, implementationModifiers? ,  identifier , genericTypesDeclaration, '(', ')' , ':' , type , ';' ;
	genericTypesDeclaration = empty | '<' , parametricTypes , '>';
	classBody = '{',classBodyDeclarations ,'}' | '{' ,'}';
		classBodyDeclarations = classBodyDeclaration | classBodyDeclarations, classBodyDeclaration;
			classBodyDeclaration = classMemberDeclaration;
		constructorDeclaration = annotations?, visibilityModifier?, implementationModifiers?, constructorDeclarator, genericTypesDeclaration, '(', constructorFormalParameterList?, ')', constructorExtension?, construtorBlock;
			constructorFormalParameterList = constructorFormalParameter | constructorFormalParameterList, ',' , constructorFormalParameter;
			constructorFormalParameter =  visibilityModifier? , imutabilityModifier?,  variableName, ':' , type ; 
			constructorExtension = 'extends' , 'super' , '(', argumentList?, ')' | 'extends' , 'this' , '(', argumentList?, ')' | 'extends' , 'super' , '.' , identifier,  '(', argumentList?, ')' | 'extends' , 'this' , '.' , identifier,  '(', argumentList?, ')' ;
			construtorBlock = ';' | block;
			constructorDeclarator = 'constructor'  | 'constructor', identifier | 'implicit', 'constructor'  | 'implicit', 'constructor', identifier;
		classMemberDeclaration =  methodDeclaration | constructorDeclaration | propertyDeclaration | indexerDeclaration | abstractIndexerDeclaration;
			propertyDeclaration =  typedPropertyDeclaration | nonTypedPropertyDeclaration ;
				typedPropertyDeclaration =  annotations?,  visibilityModifier?, implementationModifiers? , imutabilityModifier?, identifier, ':', type, propertyDeclarationInit ;
				nonTypedPropertyDeclaration =  annotations?, visibilityModifier?, implementationModifiers? , imutabilityModifier?, identifier, propertyDeclarationInit ;
					propertyDeclarationInit = ';' | propertyDeclarationHead | '=>', expression , ';' | '=', literal, ';' | '=', literal , propertyDeclarationHead , ';' ;
					propertyDeclarationHead = '{' , propertyMembers, '}';
					propertyMembers = propertyMember | propertyMembers , propertyMember;
						propertyMember = annotations?, visibilityModifier?, 'get', ';' | annotations?, visibilityModifier?, 'get', '{' , blockStatements , '}' | annotations?, visibilityModifier?, 'set', ';' | annotations?, visibilityModifier?, 'set', '(', identifier, ')', '{' , blockStatements , '}';
			indexerDeclaration = annotations?, visibilityModifier?, implementationModifiers? ,  '[' , formalParameterList , ']' , ':' , type , propertyDeclarationInit;
			abstractIndexerDeclaration = annotations?, visibilityModifier?, implementationModifiers? ,  '[' , formalParameterList , ']' , ':' , type , abstractPropertyHead;
type = nonNullType | nonNullType , '?' ;
nonNullType = identifier | identifier , '<' , parametricTypes , '>' | '(' , tupleTypes , ')';
tupleTypes = type | tupleTypes , ',' , type;
parametricTypes = parametricType | parametricTypes , ',', parametricType;
	parametricType = varianceModifier , type;
variableName = identifier;
methodDeclaration= methodHeader ,':', type , methodBody | methodHeader, ':', type , ';' | methodHeader ,':', type , '=>', expression , ';' | methodHeader, ';' |  methodHeader , methodBody | methodHeader , '=>', expression , ';';
	methodHeader = annotations?, visibilityModifier?, implementationModifiers? , identifier , genericTypesDeclaration, '(', formalParameterList , ')' | annotations?, visibilityModifier?, implementationModifiers? , identifier , genericTypesDeclaration, '(', ')'; 
	methodBody = block ;
block =  '{' , '}' | '{' , blockStatements , '}';
formalParameterList = formalParameter | formalParameterList, ',', formalParameter;
	formalParameter =  variableName, ':' , type;
blockStatements = blockStatement | blockStatements, blockStatement;
	blockStatement = localVariableDeclarationStatement | statement;
		localVariableDeclarationStatement = imutabilityModifier? , 'let' , variableName, ':' , type, ';' | imutabilityModifier? , 'let' , variableName , '=' , expression, ';' | imutabilityModifier? , 'let' , variableName, ':', type , '=' , expression, ';' ;
		statement= expressionStatement | whileStatement | forStatement | ifThenStatement | switchStatement | returnStatement | breakStatement | continueStatement | tryStatement | throwsStatement | assertStatement;
			returnStatement =  'return', expression, ';' |  'return', ';';
			throwsStatement = 'throw', expression, ';' ;
			assertStatement = 'assert', '(', expression, ')' , ';' | 'assert', '(', expression, ',' , expression , ')' , ';' ;
			breakStatement = 'break', identifier, ';' | 'break', ';' ;
			continueStatement= 'continue', identifier, ';' | 'continue', ';';
			tryStatement= 'try', resource?, block, catches?, finally?;
			resource = '(' , assignment, ')';
					assignment = leftHandSide, assignmentOperator, expression; 
					assignmentOperator = '=' |'*=' | '/=' |'%=' |'-=' |'+=' | '<<=' |'>>=' | '>>>=' | '&=' | '^=' | '|=';
					leftHandSide = fieldAccess | arrayAccess;
			catches = catchClause | catches , catchClause;
			catchClause= 'catch', '(', formalParameter ,')', block;
			finally = 'finally', block;
			expressionStatement= statementExpression , ';';
				statementExpression= assignment | expression;
			whileStatement= 'while', '(', expression, ')',  block | 'while', '(', expression, ')';
			forStatement= 'for',  '(', iterationType , 'in', expression ,')', block;
				iterationType = variableName  | 'let' , variableName;
			ifThenStatement = 'if', '(', expression ,')', block | 'if', '(', expression ,')', block , 'else', elseOptions;
				elseOptions =  block | ifThenStatement ;
			switchStatement = 'switch', '(', leftHandSide, ')', switchBlock;
				switchBlock = '{', switchLabels, '}';
				switchLabels= switchLabel | switchLabels, switchLabel;
				switchLabel = 'case', '(',  expression , ')' , block | 'default' , block;
			expression = variableName | lambdaExpression;
			lambdaExpression = lambda | conditionalExpression;
				lambda = '(' , lambdaParameters , ')' , '->', expression |  variableName , '->', expression |  '(' , ')' , '->', expression;
				lambdaParameters = formalParameterList | variableNamesList;
					variableNamesList = variableName | variableNamesList, ',', variableName;
			conditionalExpression= conditionalOrExpression | ternaryExpression;
			ternaryExpression = conditionalOrExpression, '?', expression, ':', expression;
			conditionalOrExpression = conditionalAndExpression | conditionalOrExpression ,'||', conditionalAndExpression;
			conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression, '&&', inclusiveOrExpression;
			inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression , '|', exclusiveOrExpression;
			exclusiveOrExpression = andExpression | exclusiveOrExpression, '^', andExpression;
			andExpression = equalityExpression | andExpression, '&', equalityExpression;
			equalityExpression = relationalExpression | equalityExpression, equalityOperator, relationalExpression;
				equalityOperator = '==' | '!=' | '===' | '!==' | '<=>';
			relationalExpression = shiftExpression | relationalExpression, compareOperator, shiftExpression | relationalExpression, 'is', typeObject;
				typeObject = identifier;
				compareOperator = '<' | '>' | '<=' | '>=';
			shiftExpression = additiveExpression | shiftExpression, shiftOperator, additiveExpression;
				shiftOperator = '<<' | '>>' | '>>>';
			additiveExpression = multiplicativeExpression | additiveExpression, additiveOperator, multiplicativeExpression;
				additiveOperator = '+' | '++' | '-' | '&+' | '&-';
			multiplicativeExpression = powerExpression |  multiplicativeExpression, multiplicativeOperator, powerExpression;
				multiplicativeOperator = '*' | '&*' | '/' | '\' | '%';
			powerExpression = rangeExpression |  powerExpression ,powerOperator, rangeExpression;
				powerOperator = '^^' ;
			rangeExpression = unaryExpression | unaryExpression , '..', unaryExpression | unaryExpression , '..<', unaryExpression | intervalStart , unaryExpression , ',', unaryExpression, intervalEnd | '|(' , '*' , ',', unaryExpression, intervalEnd | intervalStart , unaryExpression , ',', '*', ')|'  ; 
				intervalStart = '|[' | '|(';
				intervalEnd = ')|' | ']|' ;
			unaryExpression = unaryExpressionNotPlusMinus | unaryAditiveOperator, unaryExpression;
				unaryAditiveOperator = '+' | '-';
			unaryExpressionNotPlusMinus = juxpositionExpression | unaryMultiplicativeOperator, unaryExpression;
			unaryMultiplicativeOperator = '~' | '!' ;
			juxpositionExpression =  primary | primary, identifier;
				primary = literal | 'this' | 'super' | '(', expression ,')' | classInstanceCreationExpression | fieldAccess | arrayAccess | methodInvocation;
					fieldAccess= primary ,'.', identifier | identifier;
					arrayAccess = primary ,'[', argumentList, ']' | primary, '[', argumentList, ']';
					classInstanceCreationExpression = 'new' , creationType, '(', argumentList, ')' | 'new' ,creationType, '(', ')' | 'new' ,creationType, '.' , identifier, '(', argumentList, ')' | 'new' ,creationType,  '.' , identifier, '(', ')';
						creationType = identifier | identifier , '<', parametricTypes , '>';
						argumentList = argument | argumentList, ',', argument;
						argument = expression | identifier , ':' , expression;
					methodInvocation= primary ,'.', identifier , '(', argumentList? ,')' | identifier , '(', argumentList? ,')';
					literal= numberLiteral | booleanLiteral | stringLiteral | noneLiteral | arrayInitializer | tupleInitializer | mapInitializer;
						arrayInitializer = '[' , arrayInitializerVariables , ']';
							arrayInitializerVariables = expression | arrayInitializerVariables , ',' , expression;
						tupleInitializer = '(' , tupleInitializerVariables , ')' | '(' , ')';
							tupleInitializerVariables = expression | tupleInitializerVariables , ',' , expression;
						mapInitializer = '{' , mapInitializerVariables , '}';
							mapInitializerVariables = mapInitializerPair | mapInitializerVariables, ',' , mapInitializerPair;
							mapInitializerPair = expression , '->' , expression;
					numberLiteral = number;
					booleanLiteral= 'true' | 'false';
					stringLiteral = text;
					noneLiteral = 'none';