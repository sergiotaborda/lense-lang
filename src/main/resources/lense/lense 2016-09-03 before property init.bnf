unit = moduleDeclaration | packageDeclaration |  importDeclarations?, typeDeclarations;
moduleDeclaration = 'module' , qualifiedName, '(', versionLiteral, ')',  moduleBody ;
moduleBody = '{', '}' | '{' , moduleMemberDeclarations , '}';
moduleMemberDeclarations = moduleMemberDeclaration | moduleMemberDeclarations, moduleMemberDeclaration;
moduleMemberDeclaration = moduleImport | moduleExport;
moduleImport = 'import' , qualifiedName , versionMatchLiteral, ';';
versionMatchLiteral = versionLiteral | versionLiteral , '+' ;
moduleExport = 'export' , qualifiedName , '.' , '*', ';' | 'export' , qualifiedName , ';';
packageDeclaration  = 'package' , qualifiedName , ';' ;
qualifiedName = identifier | qualifiedName , '.' , identifier; 
importDeclarations = importDeclaration | importDeclarations , importDeclaration;
importDeclaration = 'import' , qualifiedName , ';' | 'import' , qualifiedName  ,'as', identifier, ';' | 'import' , qualifiedName , '{' , importTypes, '}';
importTypes = importName | importTypes , ',' , importName;
importName = identifier | identifier, 'as', identifier ;
typeDeclarations = typeDeclaration | typeDeclarations ,  typeDeclaration;
typeDeclaration = classDeclaration | interfaceDeclaration | objectDeclaration;
classDeclaration = annotations?, 'class', qualifiedName, genericTypesDeclaration, superDeclaration, implementsInterfaces?,  classBody;
objectDeclaration = annotations?, 'object', qualifiedName, superDeclaration, implementsInterfaces?,  classBody;
implementsInterfaces = 'implements', extendsInterfaceType;
interfaceDeclaration = annotations?, 'interface', qualifiedName, genericTypesDeclaration, extendsInterfaces? , interfaceBody;
extendsInterfaces = 'extends', extendsInterfaceType;
extendsInterfaceType = type | extendsInterfaceType, ',', type;
interfaceBody= '{', interfaceMemberDeclarations ,'}' | '{' , '}';
interfaceMemberDeclarations= interfaceMemberDeclaration | interfaceMemberDeclarations , interfaceMemberDeclaration;
interfaceMemberDeclaration= fieldDeclaration | abstractMethodDeclaration | abstractPropertyDeclaration | abstractIndexerDeclaration;
fieldDeclaration =  annotations?, imutabilityModifier , variableName, ':' , type , ';' | annotations?, imutabilityModifier , variableName, '=' , expression , ';' | annotations?, imutabilityModifier , variableName, ':', type,  '=' , expression , ';' ;
localVariableDeclarationStatement = imutabilityModifier , variableName, ':' , type, ';' | imutabilityModifier , variableName , '=' , expression, ';' | imutabilityModifier , variableName, ':', type , '=' , expression, ';' ;
imutabilityModifier = 'var' | 'val';
abstractMethodDeclaration = annotations?, 'function', identifier ,'(', formalParameterList , ')' , ':',  type , ';' | annotations?, 'function', identifier ,'(', ')' , ':' , type , ';' ;
annotations = annotation | annotations , annotation;
annotation = identifier;
genericTypesDeclaration = empty | '<' , parametricTypes , '>';
superDeclaration = empty | 'extends' , type;
classBody = '{',classBodyDeclarations ,'}' | '{' ,'}';
classBodyDeclarations = classBodyDeclaration | classBodyDeclarations, classBodyDeclaration;
classBodyDeclaration = classMemberDeclaration;
constructorDeclaration = annotations?, constructorDeclarator, '(', formalParameterList?, ')',  construtorBlock;
construtorBlock = ';' | block;
constructorDeclarator = 'constructor'  | 'constructor', identifier | 'implicit', 'constructor'  | 'implicit', 'constructor', identifier;
classMemberDeclaration = fieldDeclaration | methodDeclaration | constructorDeclaration | abstractPropertyDeclaration | propertyDeclaration | indexerDeclaration | abstractIndexerDeclaration;
abstractPropertyDeclaration = annotations?,  identifier , ':' , type , abstractPropertyHead ;
abstractPropertyHead = '{' , '}' | '{' ,  abstractPropertyMembers , '}';
abstractPropertyMembers = abstractPropertyMember | abstractPropertyMembers, abstractPropertyMember;
abstractPropertyMember =  annotations?, 'set', ';' | annotations?, 'get', ';';
propertyDeclaration =  annotations?,  identifier, ':', type,  propertyDeclarationHead;
propertyDeclarationHead = '{' , '}' | '{' , propertyMembers, '}';
propertyDeclarationShortHandHead = '{' , '}' , '=' , expression , ';' | '{' , propertyMembers, '}' , '=' , expression , ';' | '=>' , expression, ';' | '=>', '{' , blockStatements , '}';
propertyMembers = propertyMember | propertyMembers , propertyMember;
propertyMember = annotations?, 'get', '{' , blockStatements , '}' | annotations?, 'set', '(', identifier, ')', '{' , blockStatements , '}';
indexerDeclaration = annotations?,  '[' , formalParameterList , ']' , ':' , type , propertyDeclarationHead;
abstractIndexerDeclaration = annotations?,  '[' , formalParameterList , ']' , ':' , type , abstractPropertyHead;
type = identifier | identifier , '<' , parametricTypes , '>' | '(' , tupleTypes , ')' ;
tupleTypes = type | tupleTypes , ',' , type;
parametricTypes = parametricType | parametricTypes , ',', parametricType;
parametricType = varianceModifier , type;
varianceModifier = 'in' | 'out' | 'inv' | empty;
variableName = identifier;
methodDeclaration= methodHeader ,':', type , methodBody | methodHeader, ':', type , ';' | methodHeader ,':', type , '=>', expression , ';' |  methodHeader ,':', type, '=>', '{' , blockStatements , '}' | methodHeader , '=>', expression , ';' |  methodHeader , '=>', '{' , blockStatements , '}';
methodHeader = annotations?, 'function', identifier ,'(', formalParameterList , ')' | annotations?, 'function', identifier ,'(', ')'; 
methodBody = block ;
block =  '{' , '}' | '{' , blockStatements , '}';
formalParameterList = formalParameter | formalParameterList, ',', formalParameter;
formalParameter =  variableName, ':' , type;
blockStatements = blockStatement | blockStatements, blockStatement;
blockStatement = localVariableDeclarationStatement | statement;
statement= expressionStatement | whileStatement | forStatement | ifThenStatement | switchStatement | returnStatement | breakStatement | continueStatement | tryStatement;
returnStatement=  'return', expression, ';' |  'return', ';';
breakStatement = 'break', identifier, ';' | 'break', ';' ;
continueStatement= 'continue', identifier, ';' | 'continue', ';';
tryStatement= 'try', resource?, block, catches?, finally?;
resource = '(' , assignment, ')';
catches = catchClause | catches , catchClause;
catchClause= 'catch', '(', formalParameter ,')', block;
finally = 'finally', block;
expressionStatement= statementExpression , ';';
statementExpression= assignment | postincrementExpression  | postdecrementExpression | methodInvocation | classInstanceCreationExpression;
whileStatement= 'while', '(', expression, ')',  block | 'while', '(', expression, ')';
forStatement= 'for',  '(', iterationType , 'in', expression ,')', block;
iterationType = variableName  | 'val' , variableName;
ifThenStatement = 'if', '(', expression ,')', block | 'if', '(', expression ,')', block , 'else', elseOptions;
elseOptions =  block | ifThenStatement ;
switchStatement = 'switch', '(', constantExpression, ')', switchBlock;
switchBlock = '{', switchLabels, '}';
switchLabels= switchLabel | switchLabels, switchLabel;
switchLabel = 'case', '(',  expression , ')' , block | 'default' , block;
constantExpression= leftHandSide;
expression = variableName | lambdaExpression | assignment;
lambdaExpression = lambda | conditionalExpression;
lambda = '(' , lambdaParameters , ')' , '->', expression |  variableName , '->', expression |  '(' , ')' , '->', expression;
lambdaParameters = formalParameterList | variableNamesList;
variableNamesList = variableName | variableNamesList, ',', variableName;
conditionalExpression= conditionalOrExpression | ternaryExpression;
ternaryExpression = conditionalOrExpression, '?', expression, ':', expression;
conditionalOrExpression = conditionalAndExpression | conditionalOrExpression ,'||', conditionalAndExpression;
conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression, '&&', inclusiveOrExpression;
inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression '|' exclusiveOrExpression;
exclusiveOrExpression = andExpression | exclusiveOrExpression, '^', andExpression;
andExpression = equalityExpression | andExpression, '&', equalityExpression;
equalityExpression = relationalExpression | equalityExpression, equalityOperator, relationalExpression;
equalityOperator = '==' | '!=' | '===' | '!==';
relationalExpression = shiftExpression | relationalExpression, compareOperator, shiftExpression | relationalExpression, 'instanceof', shiftExpression;
compareOperator = '<' | '>' | '<=' | '>=';
shiftExpression = additiveExpression | shiftExpression, shiftOperator, additiveExpression;
shiftOperator = '<<' | '>>' | '>>>';
additiveExpression = multiplicativeExpression | additiveExpression, '+', multiplicativeExpression | additiveExpression, '-', multiplicativeExpression;
multiplicativeExpression = rangeExpression |  multiplicativeExpression ,multiplicativeOperator, rangeExpression;
multiplicativeOperator = '*' | '/' | '%';
rangeExpression = unaryExpression | unaryExpression , '..', unaryExpression | unaryExpression , '...', unaryExpression | unaryExpression , '..<', unaryExpression | unaryExpression , '>..', unaryExpression| '*..', unaryExpression | unaryExpression , '..*' | unaryExpression , '>..<', unaryExpression;
unaryExpression = unaryExpressionNotPlusMinus | unaryAditiveOperator, unaryExpression;
unaryAditiveOperator = '+' | '-'| '++' |'--';
unaryExpressionNotPlusMinus = postfixExpression | unaryMultiplicativeOperator, unaryExpression;
unaryMultiplicativeOperator = '~' | '!' ;
postfixExpression = primary | expressionName | postincrementExpression  | postdecrementExpression;
postincrementExpression = postfixExpression, '++';
postdecrementExpression = postfixExpression, '--';
assignment = leftHandSide, assignmentOperator, expression; 
assignmentOperator = '=' |'*=' | '/=' |'%=' |'-=' |'+=' | '<<=' |'>>=' | '>>>=' | '&=' | '^=' | '|=';
leftHandSide = expressionName | fieldAccess | arrayAccess;
fieldAccess= primary ,'.', identifier | 'super', '.', identifier;
arrayAccess = expressionName ,'[', expression, ']' | primary, '[', expression, ']';
expressionName= identifier | ambiguousName, '.', identifier;
ambiguousName= identifier | ambiguousName, '.', identifier;
primary = literal | 'this' | '(', expression ,')' | fieldAccess | arrayAccess | classInstanceCreationExpression | methodInvocation;
classInstanceCreationExpression = 'new' ,type, '(', argumentList, ')' | 'new' ,type, '(', ')' | 'new' ,type, '.' , identifier, '(', argumentList, ')' | 'new' ,type,  '.' , identifier, '(', ')';
argumentList = expression | argumentList, ',', expression;
methodInvocation= qualifiedName, '(', argumentList?, ')' | primary ,'.', identifier , '(', argumentList? ,')' | 'super', '.', identifier, '(', argumentList?, ')';
literal= numberLiteral | booleanLiteral | stringLiteral | nullLiteral | arrayInitializer | tupleInitializer | mapInitializer;
arrayInitializer = '[' , arrayInitializerVariables , ']';
tupleInitializer = '(' , tupleInitializerVariables , ')' | '(' , ')';
arrayInitializerVariables = expression | arrayInitializerVariables , ',' , expression;
tupleInitializerVariables = expression | tupleInitializerVariables , ',' , expression;
mapInitializer = '{' , mapInitializerVariables , '}';
mapInitializerVariables = mapInitializerPair | mapInitializerVariables, ',' , mapInitializerPair;
mapInitializerPair = expression , ':' , expression;
numberLiteral = number;
booleanLiteral= 'true' | 'false';
stringLiteral = text;
nullLiteral = 'null';