unit = packageDeclaration? , importDeclarations? , typeDeclarations?;
packageDeclaration  = 'package' , packageName , ';' ;
packageName = identifier | packageName ,  '.' , identifier;
importDeclarations = importDeclaration | importDeclarations , importDeclaration;
importDeclaration = singleTypeImportDeclaration | typeImportOnDemandDeclaration;
singleTypeImportDeclaration = 'import' , typeName , ';' ;
typeImportOnDemandDeclaration = 'import' , packageName , '.' ,  '*' , ';';
typeDeclarations = typeDeclaration | typeDeclarations ,  typeDeclaration;
typeName = identifier | packageName , '.',  identifier;
typeDeclaration = classDeclaration | interfaceDeclaration | empty ;
classDeclaration = classModifiers? , 'class', identifier, superDeclaration?, interfaces?, classBody;
classModifiers = classModifier | classModifiers, classModifier;
classModifier = 'public' |'abstract' | 'final';
superDeclaration = 'extends' , classType;
interfaces = 'implements' , interfaceTypeList;
interfaceTypeList = interfaceType | interfaceTypeList , ',' , interfaceType;
classBody = '{', classBodyDeclarations? ,'}';
staticInitializer = 'static', block;
classBodyDeclarations = classBodyDeclaration | classBodyDeclarations, classBodyDeclaration;
classBodyDeclaration = classMemberDeclaration | staticInitializer | constructorDeclaration;
classMemberDeclaration = fieldDeclaration | methodDeclaration;
fieldDeclaration = fieldModifiers?, type, variableDeclarators, ';' ;
methodDeclaration= methodHeader , methodBody;
methodBody = block | empty ;
block = '{', blockStatements? ,'}';
methodHeader = methodModifiers?, resultType, methodDeclarator, throws? ;
constructorDeclaration = constructorModifiers?, constructorDeclarator, throws?, constructorBody;
constructorModifiers = constructorModifier | constructorModifiers, constructorModifier;
constructorModifier = 'public' | 'protected' | 'private';
constructorDeclarator = simpleTypeName, '(', formalParameterList?, ')';
formalParameterList = formalParameter | formalParameterList, ',', formalParameter;
formalParameter = type, variableDeclaratorId;
throws = 'throws', classTypeList;
classTypeList = classType | classTypeList, ',', classType;
constructorBody = '{', explicitConstructorInvocation?, blockStatements?, '}';
explicitConstructorInvocation = 'this', '(', argumentList? ,')' | 'super', '(', argumentList? ,')';
fieldModifiers = fieldModifier | fieldModifiers, fieldModifier;
fieldModifier = 'public' | 'protected' | 'private' | 'static' | 'final' | 'transient' | 'volatile';
variableDeclarators = variableDeclarator | variableDeclarators, ',', variableDeclarator;
variableDeclarator= variableDeclaratorId | variableDeclaratorId, '=', variableInitializer;
variableDeclaratorId = identifier | variableDeclaratorId, '[', ']';
variableInitializer= expression | arrayInitializer;
resultType= type | 'void';
methodModifiers= methodModifier |methodModifiers, methodModifier;
methodModifier = 'public' | 'protected' | 'private' | 'static' | 'abstract' | 'final' | 'synchronized' | 'native' ;
methodDeclarator= identifier ,'(', formalParameterList?, ')' ;
interfaceDeclaration = interfaceModifiers?, 'interface', identifier, extendsInterfaces?, interfaceBody;
interfaceModifiers = interfaceModifier | interfaceModifiers, interfaceModifiers;
interfaceModifier = 'public' | 'abstract';
extendsInterfaces = 'extends', interfaceType | extendsInterfaces, ',', interfaceType;
interfaceBody= '{', interfaceMemberDeclarations? ,'}';
interfaceMemberDeclarations= interfaceMemberDeclaration | interfaceMemberDeclarations , interfaceMemberDeclaration;
interfaceMemberDeclaration= constantDeclaration | abstractMethodDeclaration;
constantDeclaration = constantModifiers, type, variableDeclarator;
constantModifiers = 'public' | 'static' | 'final' ;
abstractMethodDeclaration = abstractMethodModifiers?, resultType, methodDeclarator, throws? ;
abstractMethodModifiers= abstractMethodModifier | abstractMethodModifiers, abstractMethodModifier;
abstractMethodModifier = 'public' | 'abstract';
arrayInitializer= '{', variableInitializers? ,'}';
variableInitializers = variableInitializer | variableInitializers, ',', variableInitializer;
type= primitiveType | referenceType;
primitiveType= numericType | 'boolean';
numericType = integralType | floatingPointType;
integralType = 'byte' | 'short' | 'int' | 'long' | 'char';
floatingPointType=  'float' | 'double';
referenceType= classOrInterfaceType | arrayType;
classOrInterfaceType = classType | interfaceType;
classType= typeName;
interfaceType = typeName;
arrayType= type, '[' ,']';
blockStatements = blockStatement | blockStatements, blockStatement;
blockStatement = localVariableDeclarationStatement | statement;
localVariableDeclarationStatement= localVariableDeclaration;
localVariableDeclaration= type, variableDeclarators;
statement= statementWithoutTrailingSubstatement | labeledStatement | ifThenStatement | ifThenElseStatement | whileStatement | forStatement;
statementNoShortIf= statementWithoutTrailingSubstatement | labeledStatementNoShortIf | ifThenElseStatementNoShortIf | whileStatementNoShortIf | forStatementNoShortIf;
statementWithoutTrailingSubstatement= block | emptyStatement | expressionStatement | switchStatement | doStatement | breakStatement | continueStatement | returnStatement | synchronizedStatement | throwsStatements | tryStatement;
emptyStatement= empty;
labeledStatement= identifier, ':', statement;
labeledStatementNoShortIf= identifier, ':', statementNoShortIf;
expressionStatement= statementExpression;
statementExpression= assignment | preincrementExpression | postincrementExpression | predecrementExpression | postdecrementExpression | methodInvocation | classInstanceCreationExpression;
ifThenStatement = 'if', '(', expression ,')', statement;
ifThenElseStatement = 'if', '(', expression, ')', statementNoShortIf, 'else', statement;
ifThenElseStatementNoShortIf = 'if', '(', expression ,')', statementNoShortIf, 'else', statementNoShortIf;
switchStatement = 'switch', '(', expression, ')', switchBlock;
switchBlock = '{', switchBlockStatementGroups? , switchLabels?, '}';
switchBlockStatementGroups = switchBlockStatementGroups | switchBlockStatementGroups, switchBlockStatementGroup;
switchBlockStatementGroup= switchLabels , blockStatements;
switchLabels= switchLabel | switchLabels, switchLabel;
switchLabel = 'case', constantExpression ,':' | 'default' ,':' ;
whileStatement= 'while', '(', expression, ')', statement;
whileStatementNoShortIf = 'while', '(', expression, ')', statementNoShortIf;
doStatement= 'do', statement, 'while', '(' , expression, ')', ';';
forStatement= 'for',  '(', forInit?, ';', expression?, ';', forUpdate? ,')', statement;
forStatementNoShortIf = 'for', '(', forInit? ,';', expression?, ';', forUpdate?, ')', statementNoShortIf;
forInit= statementExpressionList | localVariableDeclaration;
forUpdate = statementExpressionList;
statementExpressionList = statementExpression | statementExpressionList, ',', statementExpression;
breakStatement = 'break', identifier?, ';' ;
continueStatement= 'continue', identifier?, ';' ;
returnStatement= 'return', expression?, ';';
throwsStatement= 'throw', expression, ';';
synchronizedStatement= 'synchronized' ,'(', expression ,')', block;
tryStatement= 'try', block, catches | 'try', block, catches?, finally;
catches = catchClause | catches , catchClause;
catchClause= 'catch', '(', formalParameter ,')', block;
finally = 'finally', block;
constantExpression= expression;
expression = assignmentExpression;
assignmentExpression= conditionalExpression | assignment;
assignment = leftHandSide, assignmentOperator, assignmentExpression;
leftHandSide = expressionName | fieldAccess | arrayAccess;
assignmentOperator = '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';
conditionalExpression= conditionalOrExpression | conditionalOrExpression, '?', expression, ':', conditionalExpression;
conditionalOrExpression = conditionalAndExpression | conditionalOrExpression ,'||', conditionalAndExpression;
conditionalAndExpression = inclusiveOrExpression | conditionalAndExpression, '&&', inclusiveOrExpression;
inclusiveOrExpression= exclusiveOrExpression | inclusiveOrExpression '|' exclusiveOrExpression;
exclusiveOrExpression = andExpression | exclusiveOrExpression, '^', andExpression;
andExpression = equalityExpression | andExpression, '&', equalityExpression;
equalityExpression = relationalExpression | equalityExpression, '==', relationalExpression | equalityExpression, '!=', relationalExpression;
relationalExpression = shiftExpression | relationalExpression, '<', shiftExpression | relationalExpression, '>', shiftExpression | relationalExpression, '<=', shiftExpression | relationalExpression, '>=', shiftExpression | relationalExpression, 'instanceof', shiftExpression;
shiftExpression = additiveExpression | shiftExpression, '<<', additiveExpression | shiftExpression, '>>', additiveExpression | shiftExpression, '>>>', additiveExpression;
additiveExpression = multiplicativeExpression | additiveExpression, '+', multiplicativeExpression | additiveExpression, '-', multiplicativeExpression;
multiplicativeExpression = unaryExpression | multiplicativeExpression ,'*', unaryExpression | multiplicativeExpression ,'/',unaryExpression | multiplicativeExpression ,'%', unaryExpression;
castExpression = '(', primitiveType ,')', unaryExpression | '(', referenceType ,')', unaryExpressionNotPlusMinus;
unaryExpression = preincrementExpression | predecrementExpression | '+', unaryExpression | '-', unaryExpression | unaryExpressionNotPlusMinus;
preincrementExpression = '++', unaryExpression;
predecrementExpression = '--', unaryExpression;
unaryExpressionNotPlusMinus = postfixExpression | '~', unaryExpression | '!' ,unaryExpression | castExpression;
postdecrementExpression= postfixExpression, '--';
postincrementExpression= postfixExpression, '++';
postfixExpression = primary | expressionName | postincrementExpression | postdecrementExpression;
methodInvocation= methodName, '(', argumentList?, ')' | primary ,'.', identifier , '(', argumentList? ,')' | 'super', '.', identifier, '(', argumentList?, ')';
fieldAccess= primary ,'.', identifier | 'super', '.', identifier;
primary = primaryNoNewArray | arrayCreationExpression;
primaryNoNewArray = literal | 'this' | '(', expression ,')' | classInstanceCreationExpression | fieldAccess | methodInvocation | arrayAccess;
classInstanceCreationExpression = 'new' ,classType, '(', argumentList?, ')';
argumentList = expression | argumentList, ',', expression;
arrayCreationExpression = 'new', primitiveType, dimExprs, dims? | 'new', classOrInterfaceType, dimExprs, dims?;
dimExprs= dimExpr | dimExprs, dimExpr;
dimExpr= '[', expression ,']';
dims= '[', ']' | dims, '[' ,']';
arrayAccess = expressionName ,'[', expression, ']' | primaryNoNewArray, '[', expression, ']';
simpleTypeName = identifier;
expressionName= identifier | ambiguousName, '.', identifier;
methodName= identifier | ambiguousName, '.', identifier;
ambiguousName= identifier |ambiguousName, '.', identifier;
literal= integerLiteral | floatingPointLiteral | booleanLiteral | characterLiteral | stringLiteral | nullLiteral;
integerLiteral = decimalIntegerLiteral | hexIntegerLiteral | octalIntegerLiteral;
decimalIntegerLiteral= decimalNumeral, integerTypeSuffix?;
hexIntegerLiteral = hexNumeral, integerTypeSuffix?;
octalIntegerLiteral= octalNumeral, integerTypeSuffix?;
integerTypeSuffix= 'l' | 'L';
decimalNumeral = '0' | nonZeroDigit, digits?;
digits= digit | digits, digit;
digit= '0' | nonZeroDigit;
nonZeroDigit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
hexNumeral = '0', 'x', hexDigit | '0' ,'X', hexDigit | hexNumeral, hexDigit;
hexDigit  = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';
octalNumeral = '0', octalDigit | octalNumeral, octalDigit;
octalDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7';
floatingPointLiteral = digits ,'.', digits?, exponentPart?, floatTypeSuffix?;
exponentPart= exponentIndicator, signedInteger;
exponentIndicator= 'e' | 'E';
signedInteger = sign? ,digits;
sign= '+' | '-';
floatTypeSuffix = 'f' | 'F' | 'd' | 'D';
booleanLiteral= 'true' | 'false';
singleCharacter = charInputCharacter;
stringLiteral= '"', stringCharacters?, '"';
stringCharacters= stringCharacter | stringCharacters, stringCharacter;
stringCharacter = stringInputCharacter | escapeCharacter;
nullLiteral= 'null';
escapeCharacter = '\';