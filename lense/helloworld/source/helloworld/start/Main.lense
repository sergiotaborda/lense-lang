import lense.core.io.Console;
import lense.core.lang.Void;
import lense.core.lang.Boolean;
import lense.core.lang.BitArray;
import lense.core.math.Interval;
import lense.core.math.Natural;
import lense.core.math.Integer;
import lense.core.system.ConsoleApplication;
import lense.core.lang.Any;
import lense.core.math.Int16;
import lense.core.collections.Sequence;
import lense.core.collections.Tuple;
import lense.core.collections.Array;
import lense.core.collections.List;
import lense.core.lang.String;
import lense.core.lang.Binary;
import lense.core.math.Int32;
import lense.core.lang.Byte;
import lense.core.math.Imaginary;
import lense.core.math.Complex;
import lense.core.math.Real;
import lense.core.math.Decimal64;
import lense.core.math.Rational;
import lense.core.math.Interval;
import lense.core.math.ArithmeticException;
import helloworld.start.Matrix;
import helloworld.start.Dto;
import lense.core.math.equal;
import lense.core.math.smaller;
import lense.core.math.greater;
import lense.core.math.Comparison;
import helloworld.start.Sum;
import helloworld.start.Sequences;
import helloworld.start.Kilometer;
import helloworld.start.Quaternion;
import helloworld.start.j;
import helloworld.start.k;

public class Main extends ConsoleApplication {

	public constructor();
	
	public let parameter : Integer = 99 {get;};
	
	@teste @teste2
	private applyNames<T, U> ( from : T , to : U) : String {

		let list = new Array<T>();
		let other = new Array<U>();

		return "";
	}

	private duplicate<T> ( source : Array<T> ) : Array<T> {

		if (source.size == 0){
			return new Array<T>.empty();
		}
	
		let other = new Array<T>(source.size, source[0]);
	
		for( let i in source.indexes){
			other[i] = source[i];
		}		

		return other;
	}

	private demoReification(){
	
		let source = [1,2,3];
	    let target = duplicate(source);

		let areTheSame = source === target;

  	   	console.println("Copy and original are the same {{ areTheSame }}" );

	}

	private demoLongAndIntErrasure(){

		let a : Int32 = 4;
		let b : Int32 = 5;

		let c = a + b;
		let d = a &+ b;

		let f = a * b;
		let g = a &* b;
	
		assert (9 == c , "c is not 9, is {{ c }}");
		assert (9 == d , "d is not 9, is {{ d }}");
		assert (20 == f, "f is not 20, is {{ f }}");
		assert (20 == g, "g is not 20, is {{ g }}");

		assert (c is Int32, "c is Int32");
		assert (f is Int32, "f is Int32");
		
		assert (g is Int32, "g is not an Int32");
		assert (d is Int32, "d is not an Int32");
		assert (!(d is Int64), "d is an Int64");
		assert (d is Integer, "d is not an Integer");
		
		for (let i in 0 .. 5){
			a = a &+ i;
		}

		assert (19 == a, "a is not 19, is {{ a }}");
	}
	
	private  sum ( a : Int32 , b: Int32) : Int32{
		return a &+ b;
	}
	
	private  isum ( x : Int32 , y: Int32) : Integer {
		return x + y;
	}
	
	private  increment ( a : Int32) : Int32 {
		for (let i in 0 .. 5){
			a = a &+ i;
		}
		return a;
	}
	
	private  incrementTo ( a : Int32, m : Int32) : Int32 {
		for (let j in 0 .. m){
			a = a &+ j;
		}
		return a;
	}

	private demoNamedArguments (){

		let t = true;

		let a = range(2, 5, t);
		let b = range(from : 2, to : 5, negated : true);
		let c = range(to : int2(), negated: bool(), from : int1());
		let d = range( 2, negated: true, to : 5);
		let f = range( false,  to : 5, from : 2);

		assert ( a == 3);
		assert ( b == -3);
		assert ( c == 3);
		assert ( d == -3);
		assert ( f == 3);

	}

	private bool() {
		return false;
	}

	private int2() : Natural {
		return 2;
	}

	private int1() : Natural {
		return 5;
	}

	private  range(negated : Boolean,  from : Natural, to : Integer) : Integer{
		if (negated){
			return to - from;
		} else {
			return from - to;
		}
	} 

	private  range( from : Integer, to : Integer , negated : Boolean) : Integer{
		if (negated){
			return to - from;
		} else {
			return from - to;
		}
		
	} 

	private demoBinding() {
		let km = new Kilometer();
 

		let c = 1 km;

		let q : Quaternion = 4k + 3j + 2i + 1;

		assert (  new Quaternion(1,2,3,4) == q );

	}

  	public override onStart()  {

	

  	 	console.println("Begin " ++ this.type().name); 

		demoLongAndIntErrasure();

		demoBinding();

		demoReification();

		demoEnhacements();

		demoMaybeArray();  	 	

		demoList();  	 	

  		demoTryCatch();
  	 		
		demoDto();
  	 	
		demoMatrix();

		demoBitArray();

		demoSwitchAlgebric();
  	 
  		var interval : Interval<Natural> = |[ 2, 19 )|;
		var interval2 : Interval<Integer> = |[ -2, 19 )|; // TODO better promotions

		console.println(interval2);

		var a  = interval2.start;
		var b  = interval2.end;
		 
  	 	var im  = 2i; 
  	 	
  	 	var cx = 3 + 4i;

  	    var r = cx.abs();
  	 
  	 	console.println("Complex is : {{ cx }} with magnitude :{{ r }} "); 
  	 
  	 	var bx  = 4 +2i;

  	   console.println("Other Complex is : {{ bx }} ");
  	 
  	   console.println("Product is : {{ bx * cx }}");
  	 
  	 	var rational : Any = 0.3;
  	 	
  	 	console.println("");
  	 	
  	 	if (rational is Rational){
  	 		console.println("Decimal literals are rational");
  	 		var dec : Decimal64 = toRational(rational);  
  	 		console.println("dec is {{ dec }}");
  	 	} else {
  	 		console.println("Decimal literals are NOT rational");
  	 	}
  	 	 
  	    var decimal : Decimal64 = 0.5;  
  	 	   
  	 	assert ( 3/4 == 3/4);
  	 	
  	 	assert(  8 / 3 is Rational , "8/3 is not Rational");
  	 	assert(  8 \ 3 is Whole , "8 \ 3 is not Whole");
  	 	
  	 	var ratio = 8 / 3;
  	 	var wholeDivision = 8 \ 3;
  	 	var remainder = 8 % 3;

		assert (8 == 3 * wholeDivision + remainder , " Q = d * q + r is wrong");
  	 	
		var inverted = 1 / ratio;
	
		assert( 1 ==  ratio.signum() , " Sign of {{ ratio }} is not 1");

		assert( inverted ==  ratio.invert() , " 1 / x is not the same as x.invert()");

		assert( inverted == 3/8 , " Inversion is wrong");

		var fakeInverted = ratio / 1;

		assert( fakeInverted == ratio , "Fake invert is wrong");

  	 	var doubleInverted = 2 / ratio;

		assert( doubleInverted == 3/4 , "Double Inverter is wrong");

  	  // TODO correct \ escaping inside string	
  	 	console.println("8 / 3 = {{ ratio }} and 8 \ 3 ={{wholeDivision }}  so  8 ={{ wholeDivision }} * 3 + {{ remainder }}");
  	 	
   // TODO verifiy if a variable was already defined
 
  	   var pow : Natural = 4 ^^ 3;
  	   var powNeg : Rational = 4 ^^ -3;
  	   
		assert ( 64 == pow , "  4 ^^ 3 is not 64 ");

		assert ( 1/ 64 == powNeg , "  4 ^^ -3 is not 1/64 ");
  	  
  	    var distance = dist(3, 4); 
  	 	
	// TODO natural == decimal
		assert ( 5.0 == distance, "Distance is not 5, is {{ distance }}");

  	 	console.println(" distance srqt(3x3 + 4x4) = {{ distance }}");
  	 	console.println(" distance srqt(3x3 + 4x4) = {{ hypot(3, 4) }}");
  	 	
  	    console.println(" distance srqt(1 + 1) = {{ dist(1, 1) }}");
  	    console.println(" distance srqt(1 + 1) = {{ hypot(1, 1) }}");
  	    
  	    console.println(" distance srqt(5 + 7) = {{ dist(5, 7) }}");
  	    console.println(" distance srqt(5 + 7) = {{ hypot(5, 7) }}");
  	    
  	    console.println(" reduced 50/ 60 = {{ 50 / 60 }} = 5/6");
  	    console.println(" reduced 20/ 5 = {{ 20 / 5 }} = 4");
  	    
  	 	var dc = 0.5 + 4i;
  	 	
		assert ( new Complex(0.5, 4)  == dc , " Complex is not 0.5+4i");

  	 	var n = #EFA2;
  	 	
  	 	var p : Integer = parameter; 
  	 	
		assert ( 99 == parameter, " Parameter is not 99");
		assert ( 99 == p);
  
  	 	var binary = $1011_1011_0010; 
  	 	
  	 	var byte : Byte = $1011_0110; 
  	   
  	    console.println("byte is {{ byte }}");
  	   
  	   	byte = binary; // will ignore higher bits
  	   
  	    console.println("byte is {{ byte }}");
  	    
  	  	var number : Int32 = binary;
  	  	 
  		var  array = [1 , 2, -3, 4, 5];
  	
  		//console.println("sequence is {{ array }}");
  		 
  		//console.println("position 2 has value {{ array[2] }}");
  		
  		//console.println("literal sequence is {{ [1 , 2, 3, 4, 5]  }}"); 
  	 	 
  		var barray : Array<Boolean>= [false, true, true, false];
  		
  		console.println(barray);
  		
  		assert(!barray[0], "barray[0] is not false");
  		assert(barray[1], "barray[1] is not true");
  		assert(barray[2], "barray[2] is not true");
  		assert(!barray[3], "barray[3] is not false");
  		
 
  		var convertedBitArray : BitArray = barray;
  		var bitArray :  BitArray = new BitArray(4);
		
		bitArray[0] = false;
		bitArray[1] = true;
		bitArray[2] = true;
		bitArray[3] = false;

		assert ( bitArray == convertedBitArray , " BitArray created from array of booleans is not equal to fixed bit array");

  	
  	  	var map = { 1 : "a", 2 : "b", 3 : "c" };
  	 
  	  	console.println("Map is : {{ map }}");
  	   
  		var  tuple = ("Hello", 6);
  		
		assert ( "Hello" == tuple[0] , " Tuple first value is not `Hello` ");
		assert ( 6 == tuple[1] , " Tuple second value is not 6 ");

  		var  tuple3 = ("Hi", 3, true); // TODO use true in the last value
  		
		assert ( "Hi" == tuple3[0] , " Tuple first value is not `Hi` ");
		assert ( 3 == tuple3[1] , " Tuple second value is not 3 ");
		assert ( true == tuple3[2] , " Tuple second value is not 4.0 ");
  	
  	    var tuple1 : (String) = ("Hello single expression to tuple");
  		
		assert ( "Hello single expression to tuple" == tuple1[0] , " Tuple first value is not `Hello single expression to tuple` ");

    	var  tuple0 : String = ("Hello single expression");
  		
		assert ( "Hello single expression" == tuple0 , " Tuple first value is not `Hello single expression` ");


  	    for(let y in 1..10){
  	     
  	     	console.println(y);
  	     	
  	     	if ( y == 4){
  	     		console.println("Hello Four");
  	     	} else if (y > 4){
  	     		console.println("Bigger than Four");
  	     	}  else if (y < 4){
  	     		console.println("Less than Four");
  	     	}
  	        
  	     }
  	     
  	     
  	     console.println(getlength([1,2]));
  	    
  	    console.println("End");
  	 
  	}

	public demoEnhacements(){

		var seq = [1,2,3,4,5];

		var sum = seq.sum();

  		assert (sum == 15 ); 

		var alfa = [ "a", "b", "c"];

		var a = alfa.first();

		var maybeA : String? = "a";

		assert (a == maybeA ); 
	}


	public dist(x : Integer, y : Integer) : Real {
		return (x ^^ 2 + y ^^ 2) ^^ 0.5;
	}
	
	public hypot(x : Real, y : Real) : Real {

		let ax = x.abs();
		let ay = y.abs();

		let max = ax >= ay ? ax : ay;
		let min = ax >= ay ? ay : ax;


		
	   console.println(" max = {{ max }}");
	   console.println(" min = {{ min }}");
		
		let r = min / max ;
		
		  console.println("r = {{ r }}");
		  let k = r ^^ 2;
		    console.println("r ^^ 2 = {{ k }}");
		 console.println("j = {{ 1.0 + k }}");
		 
		return max * (1.0 + r ^^ 2) ^^ 0.5;

	}
	
	public toRational(number : Rational) : Rational => number;
	
	public toRationalFromAny( any : Any) : Rational{
		assert( any is Rational);
		return any;
	}

  	public getlength ( seq : Sequence<Natural>) => seq.size; 

	private demoList(){
		
		let arr : Array<Natural> = [1,2,3,4,5];

		for (a in arr){
			console.println("Element {{ a }}" );
		}

		let list : List<Natural> = arr; // implict copy 

		console.println("List size is {{ list.size }}");
		console.println("List is {{ list }}");
	}

	public demoTryCatch(){
 		try {
  	 		var f = 4 / 0;
  	 		console.println("f is " + f);
  	 	} catch (e : ArithmeticException){
  	 		console.println("try catch worked");
  	 	}
	}

	public demoDto(){

  	 	var dto = new Dto();
  	 	
		assert ( dto.age == dto.constante);
		assert ( dto.age == 34);

		assert ( dto.name == none);

  	 	console.println("name is " + dto.name);
  	 	console.println("age is " + dto.age);
  	 		
  	 	dto.name = "dto"; // directly assign to a optional property
  	 	
  	 	var address = dto.address;
  	 	
  	 	console.println("name is " + dto.name);
  	 	console.println("age is " + dto.age);
	}

	public demoMatrix(){

  		let matrix  = new Matrix<Natural>(rowsCount: 3, columnsCount: 3, seed: 0);
  	
  		matrix[2,2] = 4;
  	 
  	    let center = matrix[2,2];
  		
  		console.println(center);
	}

	public demoMaybeArray (){
		let array : Array<String?> = ["a", none , "b", "c", none];

 		console.println("array with none is  " + array);

		let a : String? = "a";
  
 		// TODO transform == to maybe when other side is not a maybe to .is(a)
		assert (array[0] == a);
		assert (array[1] == none);
	}

	public demoBitArray(){
		
		let bitArray = new BitArray($1100_1101); 
	

		assert (new BitArray($1_1001_1010) == bitArray << 1);
		assert (new BitArray($0110_0110) == bitArray >> 1);
	}

	public demoSwitchAlgebric(){

		let obj = 1 <=> 3;
		switch(obj){
			case (equal){
				console.println("equal ");
			}
			case (smaller){
				console.println("smaller");
			}
		    case(greater) {
				console.println("greater");
			}
		}

		let b = true;
		switch(b){
			case (true) { console.println("true"); }
			case (false) { console.println("false"); }
		}

		let n = 4;
		switch(n){
			case (1) {console.println("1");} 
			case (2) {console.println("2");}
			case (4) {console.println("4");}
			default {console.println("8");}    
		}
	} 
}

