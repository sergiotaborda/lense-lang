
import lense.core.math.Number;
import lense.core.math.Imaginary;
import lense.core.math.Real;

public class Complex extends Number {



 	public constructor ( private real : Real, private imaginary: Real);
	
	public constructor (){
		return new Complex(new Real.zero(), new Real.zero());
	}
	
	public implicit constructor valueOfReal( real : Real){
		return new Complex(real, new Real.zero());
	}
	
   	public implicit constructor valueOfImaginary( img : Imaginary){
		return new Complex(new Real.zero(), img.real());
	}

	public plus( other : Complex) => new Complex(this.real.plus(other.real), this.imaginary.plus(other.imaginary));

	public minus( other : Complex) => new Complex(this.real. minus(other.real), this.imaginary. minus(other.imaginary));

	public  multiply( other : Complex) {
		return new Complex(
				this.real.multiply(other.real).minus(this.imaginary.multiply(other.imaginary)) ,
				this.real.multiply(other.imaginary).plus(this.imaginary.multiply(other.real))
		);
	}

	public divide( denominator : Complex ) : Complex {
		let magnitude : Real =  denominator.abs();
		if (magnitude.isZero()){
			throw new Exception();
		}
		return this.multiply(denominator.conjugate()).divide(magnitude);
	}
	
	public divide( denominator: Real ) => new Complex(this.real.divide(denominator), this.imaginary.divide(denominator));

	public conjugate() =>  new Complex(this.real, -this.imaginary);
	
	public isZero() => real == 0 && imaginary == 0;

	public abs() => real.multiply(real).plus(this.imaginary.multiply(this.imaginary));

	public override equalsTo( other : Any) =>  other is Complex && this.real.equalsTo(other.real) && this.imaginary.equalsTo(other.imaginary);

	public override hashValue() => this.real.hashValue().concat(this.imaginary.hashValue());

	public override asString() : String {
	    var sign : String = "+";
	    if (imaginary.signum() < 0){
	    	sign = " - ";
	    }
		return real.asString() ++ sign ++  imaginary.asString() ++ "i";
	}
}