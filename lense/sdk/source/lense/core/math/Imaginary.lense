
import lense.core.math.Number;
import lense.core.math.Real;
import lense.core.math.Whole;
import lense.core.math.Equal;

public class Imaginary extends Number implements Comparable<Imaginary> {


	public implicit constructor valueOf ( private value : Real);
	
	public constructor (){
		return new Imaginary.valueOf(new Real.zero());
	}
	
	public real() => value;

	public plus( other : Imaginary) => new Imaginary(this.value + other.value);

	public minus( other: Imaginary ) => new Imaginary(this.value - other.value);
	
	public multiply( other: Imaginary) => -(this.value * other.value);
	
	public divide( other: Imaginary) => this.value.divide(other.value);

	public plus( other: Whole ) =>  plus(new Real.valueOf(other));

	public minus( other : Whole) =>  minus(new Real.valueOf(other));

	public multiply( other: Whole) => multiply(new Real.valueOf(other));

	public divide( other : Whole) => divide(new Real.valueOf(other));

	public plus( other: Real) => new Complex(other, this.value);

	public minus( other: Real ) => new Complex(-other, this.value);

	public multiply( other: Real) => new Imaginary(this.value * other);

	public divide( other: Real ) => new Imaginary(this.value / other);
	
	public asString() => this.value.asString() ++ "i";

	public symmetric() => new Imaginary(-this.value);
	
	public signum() => value.signum();
	
	public equalsTo( other : Any) {
		if (other is Imaginary){
			return this.value.equalsTo(other.value);
		}
		return false;
	}

	public isZero() : Boolean => this.value.isZero();

	public  hashValue() => value.hashValue();
	
	public compareWith(other : Any) {
		if (other is Imaginary){
			return this.value <=> other.value; 
		} 
		
	    throw new Exception(); // TODO create IncorrectTypeException
	}
}