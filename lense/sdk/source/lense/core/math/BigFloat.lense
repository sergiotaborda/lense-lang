import lense.core.math.Real;
import lense.core.math.Float;
import lense.core.math.Whole;
import lense.core.math.BigDecimal;
import lense.core.math.Rational;
import lense.core.lang.debug;
import lense.core.math.ArithmeticException;

public value class BigFloat implements Float {


	private constructor (private numerator : Integer, private denominator : Integer);

	public constructor () {
		return new BigFloat(0,1);
	}

	public implicit constructor valueOf( other: Real) {
		if (other is Rational){
			return new BigFloat(other.numerator, other.denominator).simplify();
		}
		return new BigFloat.parse(other.asString());
	}

	public implicit constructor valueOf( other: Whole){
		return new BigFloat(other.asInteger() , 1);
	}

	public implicit constructor valueOf( other: Float){
		if (other is BigFloat){
			return other;
		} else {
			return new BigFloat.parse(other.asString());
		}
	}


	public constructor parse( other: String){
		if (other == "NaN"){
		   return new BigFloat(0,0);
		} else if (other == "+Infinity"){
		   return new BigFloat(1,0);
		} else if (other == "-Infinity"){
		   return new BigFloat(-1,0);
		}

		if ( other.starstWith("-")){
			other = other.subString(1);
		}

		let pos : Maybe<Natural> = other.indexOf(".");

		if (pos.isAbsent()){
			return new BigFloat(new Whole.parse(other),1);
		} else {
			let len : Natural = pos.value; // this should not be necessary. 
			let power = other.size &- len &- 1;		

			let wholePart = new Whole.parse(other.removeAt(pos.value));

			return new BigFloat(wholePart,10 ^^ power).simplify();
		}
	}

	public override asString(): String {

		if (this.isNaN()){
			return "NaN";
		} else if (this.isPositiveInfinity()){
			return "+Infinity";
		} else if (this.isNegativeInfinity()){
			return "-Infinity";
		} else if (this.isNegativeZero()){
			return "-0";
		} else if (this.denominator == 1){
			return this.numerator.asString();
		} 
		return new BigDecimal( new Rational.fraction( this.numerator , this.denominator)).asString();

	} 

	public override equalsTo(other: Any){

		if ( other is BigFloat){
			return this.numerator == other.numerator && this.denominator == other.denominator;

		} else if ( other is Rational){
			return this.numerator == other.numerator && this.denominator == other.denominator;
		} else if (other is Imaginary || other is Complex){
			return false;
		} else if ( other is Number) {
			return equalsTo(new BigFloat.parse(other.asString()));
		}
 

		return false;
		
	} 

	public override hashValue() : HashValue {
		return numerator.hashValue().concat(denominator.hashValue());
	}

	public sign() : Integer {
		// sign of NaN is +  since its considered > +oo
		if (this.isNaN() || this.isPositiveInfinity()) {
			return 1;
		} else if (this.isNegativeInfinity() || this.isNegativeZero()) {
			return -1;
		} else if (this.isZero()) {
			return 0;
		}

		return this.numerator.sign();
	}

	public override compareWith (other : Number) : Comparison {
		
		if (other is Real){
			return compareWith(new BigFloat.valueOf(other));
		} else if (other is Whole){
			return compareWith(new BigFloat.valueOf(other));
		} else if (other is Float){

			if (this.isNaN()){
				if (other.isNaN()){
					return equal;
				} else {
					return greater;
				}
			} else if (this.isPositiveInfinity()){
				if (other.isNaN()){
					return smaller;
				} else if (other.isPositiveInfinity()) {
					return equal;
				} else {
					return greater;
				}
			} else if (this.isNegativeZero()){
				if (other.isNaN() || other.isPositiveInfinity() ||  other.isZero() || other.sign() > 0){
					return smaller;
				} else if (other.isNegativeZero()) {
					return equal;
				} else {
					return greater;
				}
			} else if (this.isNegativeInfinity()){
				if (other.isNegativeInfinity()) {
					return equal;
				} else {
					return smaller;
				}
			}
	
			let diff = this &- other;
			
		    if (diff >0){
				return greater;
			} else if (diff <0){
				return smaller;
			}
	
		   return equal;
	
				
		}

		throw new ArithmeticException(); // TODO comparison exception
	}  

	public isPositive() => this.isNaN() || this.isPositiveInfinity() || numerator.isPositive();

	public isNegative() => this.isNegativeZero() || this.isNegativeInfinity() || numerator.isNegative();

	public isNaN() => numerator == 0 && denominator == 0;

	public isNegativeZero() => numerator == 0 && denominator < 0;

	public isNegativeInfinity() => numerator < 0 && denominator == 0;

	public isPositiveInfinity() => numerator > 0 && denominator == 0;

	public isInfinity() => denominator == 0;
	
    public abs() => new BigFloat( this.numerator.abs() , this.denominator.abs());

	public symmetric() => new BigFloat( -this.numerator , -this.denominator);

	public isOne() => numerator == 1 && denominator != 0;
	public isZero() => numerator == 0 && denominator != 0;
	
    public isWhole() : Boolean {
    	return this.numerator % this.denominator == 0;
    }
    
	public floor() : Integer {
		if (this < 0){
			return -(-this).ceil();
		} else {
      		//extracted from http://www.cs.nott.ac.uk/~rcb/G51MPC/slides/NumberLogic.pdf
			return this.numerator \ this.denominator ;
		}
	}

	public ceil() : Integer {

		if (this < 0){
			return -(-this).floor();
		} else {
      		//extracted from http://www.cs.nott.ac.uk/~rcb/G51MPC/slides/NumberLogic.pdf
			return (this.numerator + this.denominator - 1) \ this.denominator;
		}
	}

	private simplify(): BigFloat {
		return simplify(this.numerator, this.denominator);
	} 

	private simplify( numerator : Integer,  denominator : Integer ) : BigFloat {
	
		if (denominator == 0){
			numerator = numerator.sign();
		} 
		if (numerator == 0){
			denominator = denominator.sign();
		}
		
		if (denominator != 1 ){
			let gcd = numerator.gcd(denominator);
			
			numerator = numerator \ gcd;
            denominator = denominator \ gcd;
		}
		
		return new BigFloat(numerator , denominator);
	
	}

	public wrapPlus (other: Float) : Float {
		 let r : BigFloat = other;

		 return simplify(
				 r.denominator * this.numerator + this.denominator * r.numerator , 
				 this.denominator * r.denominator 
		);

	}

	public wrapMinus (other: Float) : Float {
		 let r : BigFloat = other;

		 return simplify(
				 r.denominator * this.numerator - this.denominator * r.numerator , 
				 this.denominator * r.denominator 
		);

	}

	public wrapMultiply (other: Float) : Float {
		 let r : BigFloat = other;

		 return simplify(
				 this.numerator * r.numerator , 
				 this.denominator * r.denominator 
		);

	}

	public divide (other: Float) : Float {

 		let r : BigFloat = other;

		 return simplify(
				 this.numerator * r.denominator , 
				 this.denominator * r.numerator 
		);

	}

	public invert() : Float {
		if (this.isNaN()){
			return new BigFloat(0,0);
		} else if (this.isNegativeInfinity()) {
			return new BigFloat(0,-1);
		} else if (this.isPositiveInfinity()) {
			return new BigFloat(0,1);
		} else if (this.isOne()){
			return this;
		} else if (this.isZero()){
			return new BigFloat(1,0);
		}

		return new BigFloat(this.denominator, this.numerator);
	}

	public log(): Float {
		if (this.isNaN() || this <= 0 || this.isNegativeInfinity() ){
			return new BigFloat(0,0);
		} else if (this.isPositiveInfinity()) {
			return new BigFloat(1,0);
		} else if (this.isOne()){
			return new BigFloat(0,1);
		}
			
		return this.numerator.log() &- this.denominator.log();
		
	}

	public exp(): Float{

		if (this.isZero() || this.isNegativeZero() ){
			return new BigFloat(1 , 1);
		} else 	if (this.isNegativeInfinity()){
			return new BigFloat(0 , 1);
		} else 	if (this.isPositiveInfinity()){
			return new BigFloat(1 , 0);
		} else 	if (this.isNaN()){
			return new BigFloat(0 , 0);
		}

		if (this < 0){
			return this.abs().exp().invert();
		}


	    //taylor : exp(x) = 1 + x + x*x/2 + x*x*X/6 + x*x*x*x/24 +...

        var sum : BigFloat = 1 ;
   		var xpowi : BigFloat = 1 ;
		var factorial = 1;
                           
         for(let i in 1 .. 36){
			factorial *= i;
			xpowi = xpowi &* this;
			let c = xpowi / factorial;
			sum = sum &+ c;
 			if ( xpowi.abs() < i && c.abs() < 0.5 ){
  				break;
 			}                               
         }

		return sum;


		/{
		
		
		let s = this &* this;
		let t = this &* s;
		let q = s &* s;

		return 1 
			&+ (this)
		    &+ (s /2) 
			&+ (t /6) 
			&+ (q / 24) 
			&+ (t &* s / 120) 
			&+ (q &* s / 720)
			&+ (t &* q / 5040)
			&+ (q &* q / 40320)
			&+ (t &* q &* s / 362880)
			&+ (q &* q &* s / 3628800)
			&+ (t &* q &* q / 39916800)
			&+ (q &* q &* q / 479001600)
			;
		

		var hi: Float;
		var lo: Float;
		var k : Integer;

		let Ln2 = ;
		let ln2_L = 
		let ln2_H

		var x = this;
		let t = x.abs();

		if (t > 0.5 * Ln2){
			if (t < 1.5 * Ln2){
				hi = t - ln2_H
                lo = Ln2_L;
				k = 1;
			} else {
				k = (Inv_ln2 * t + 0.5).floor();
				hi = t - k * Ln2_H;
				lo = k * Ln2_L;
			}

			if (x < 0 ){
				hi = -hi;
				lo = -lo;
				k = -k;
			}
			x = hi - lo;
		} else if ( t < 1 / Two_28){
			return new BigDecimal(1,1);
		} else {
			hi = 0;
			lo = 0;
			k = 0;
		}

		t = x &* x; 
		let c = x - t &* ( P1 + t &* (P2 + t &* ( P3 + t &* ( P4 + t &* P5))));
		if (k == 0 ){
			return 1 - ( x * c / (c - 2) - x);
		} else {
			return = 1 ( lo = x * c / (2 - c ) - hi);
			
		}
			}/
	}
	
	public raiseTo(other : Float) : Float {
		return (this.log() &* other).exp();
	}
}