
import lense.core.math.Real;
import lense.core.math.Integer;
import lense.core.lang.String;
import lense.core.lang.Boolean;
import lense.core.math.ArithmeticException;

/{
	A fraction n/d 
}/
public class Rational extends Real {

	public constructor ( public val  numerator : Integer , public val denominator  :Integer);
	
	public equalsTo(other : Any) : Boolean {
		if(other is Rational){
			return this.numerator == other.numerator && this.denominator == other.denominator;
		} 
		return false;
	}

	public hashValue() : HashValue {
		return numerator.hashValue().concat(denominator.hashValue());
	}
	
	public asString() : String {
		if (this.denominator.isOne()){
			return this.numerator.asString();
		} 
		return this.numerator.asString() + "/" + this.denominator.asString();
	}
	
	private symplify( numerator : Integer,  denominator : Integer ) : Rational {
		return new Rational(numerator,denominator );
	}
	
	public plus( other : Real) : Real {
		if (other is Rational){
			return plus(other);
		} 
		
		return promoteNext() + other;
		
	}
	
	private  promoteNext() : Real {
		return promoteToBigDecimal(); 
	}
	
	protected promoteToBigDecimal() : BigDecimal {
		return new BigDecimal(this);
	}

	public plus( other : Rational) : Rational {
		 return symplify(
				 this.numerator * other.denominator  + this.denominator * other.numerator , 
				 this.denominator * other.denominator 
		 );
	}

	public minus( other : Real) : Real {
		if (other is Rational){
			return minus(other);
		} 
		
		return promoteNext() - other;
	}
	
	public minus( other : Rational) : Rational{
		 return symplify(
				 this.numerator * other.denominator - this.denominator * other.numerator , 
				 this.denominator * other.denominator 
		 );
	}

	public  multiply(other : Real) : Real {
		if (other is Rational){
			return multiply(other); // TODO flow senstivie cast
		} 
			
		return promoteNext() * other;
		
	}
	
	public multiply( other : Rational) : Rational {
		 return symplify(
				 this.numerator * other.numerator,
				 this.denominator * other.denominator
		 );
	}

	public divide( other : Real) : Real {
		if (other is Rational){
			return divide(other);
		} 
		
		return promoteNext().divide(other);
		
	}

	public divide( other: Rational) : Rational {
		 if (other.isZero()){
			throw new ArithmeticException("Cannot divide by zero"); 
		}
		 return symplify(
				 this.numerator * other.denominator,
				 this.denominator * other.numerator
		 );
	}
	
	public isZero() : Boolean {
		return this.numerator.isZero();
	}

	public isOne() : Boolean{
		return this.numerator.equalsTo(denominator);
	}

	public symmetric() : Real {
		return new Rational(numerator.symmetric(), denominator);
	}
	
	public signum() : Integer {
		return numerator.signum() * denominator.signum();
	}

	public asInteger() : Integer {
		return this.numerator \ this.denominator;
	}

    public isWhole() : Boolean {
    	return this.numerator % this.denominator == 0;
    }
    
    public raiseTo(other : Real) : Real {
    	if (this == 0){ // TODO intrisify x == 0 to x.isZero
    		if (other == 0){
    			return new Rational(1,1);
    		}
            return this;
        } else if ( this == 1) {
        	return this;
        } else if ( other == 0) {
        	return new Rational(1,1);
        } else if (other.isWhole()){
            val p : Integer = other.asInteger();
            val n : Natural = p.abs();
            var result : Rational = new Rational(this.numerator ** n, this.denominator ** n);
            if (p < 0) { // TODO intrisify x < 0 to x.isNegative()
                result = result.invert();
            } 
            return result;
        } else {
            return promoteToBigDecimal().raiseTo(other);
        }
    }

	public invert () : Rational {
		return new Rational(this.denominator, this.numerator);
	}
}