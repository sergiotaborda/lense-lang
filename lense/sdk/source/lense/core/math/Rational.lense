
import lense.core.math.Real;
import lense.core.math.Integer;
import lense.core.math.Natural;
import lense.core.lang.String;
import lense.core.lang.Boolean;
import lense.core.math.ArithmeticException;

/{
	A fraction n/d 
}/
public class Rational extends Real {

	private constructor ( public  numerator : Integer , public denominator : Natural);

	public constructor (  numerator : Integer ,   denominator : Integer ){
	
		if (denominator == 0){
			throw new ArithmeticException("Cannot create a Rational with zero as denominator"); 
		}
		
		if (numerator == 0){
			// all forms of zero are the same. 
			denominator = 1;
		} else if (denominator < 0){ // let the numerator carrie the sign
			numerator = -numerator;
			denominator = -denominator;
		}
		
		if (denominator != 1 ){
			let gcd = numerator.gcd(denominator);
			numerator = numerator \ gcd;
            denominator = denominator \ gcd;
		}
		
		return new Rational(numerator , denominator.abs());
	}
	
	private symplify( numerator : Integer,  denominator : Natural ) : Rational {
	
		if (numerator == 0){
			// all forms of zero are the same. 
			denominator = 1;
		} 
		
		if (denominator != 1 ){
			let gcd = numerator.gcd(denominator);
			
			// TODO log (gcd)
			numerator = numerator \ gcd;
            denominator = denominator \ gcd;
		}
		
		return new Rational(numerator , denominator);
	
	}
	
	public equalsTo(other : Any) : Boolean {
		if(other is Rational){
			return this.numerator == other.numerator && this.denominator == other.denominator;
		} 
		return false;
	}

	public hashValue() : HashValue {
		return numerator.hashValue().concat(denominator.hashValue());
	}
	
	public asString() : String {
		if (this.denominator == 1){
			return this.numerator.asString();
		} 
		return this.numerator.asString() + "/" + this.denominator.asString();
	}
	

	
	public plus( other : Real) : Real {
		if (other is Rational){
			return plus(other);
		} 
		
		return promoteNext() + other;
		
	}
	
	private  promoteNext() : Real {
		return promoteToBigDecimal(); 
	}
	
	protected promoteToBigDecimal() : BigDecimal {
		return new BigDecimal(this);
	}

	public plus( other : Rational) : Rational {
		 return symplify(
				 other.denominator * this.numerator   + this.denominator * other.numerator , 
				 this.denominator * other.denominator 
		 );
	}

	public minus( other : Real) : Real {
		if (other is Rational){
			return minus(other);
		} 
		
		return promoteNext() - other;
	}
	
	public minus( other : Rational) : Rational{
		 return symplify(
				 other.denominator * this.numerator  - this.denominator * other.numerator , 
				 this.denominator * other.denominator 
		 );
	}

	public  multiply(other : Real) : Real {
		if (other is Rational){
			return multiply(other); // TODO flow senstivie cast
		} 
			
		return promoteNext() * other;
		
	}
	
	public multiply( other : Rational) : Rational {
		 return symplify(
				 this.numerator * other.numerator,
				 this.denominator * other.denominator
		 );
	}

	public divide( other : Real) : Real {
		if (other is Rational){
			return divide(other);
		} 
		
		return promoteNext().divide(other);
		
	}

	public divide( other: Rational) : Rational {
		 if (other == 0){
			throw new ArithmeticException("Cannot divide by zero"); 
		}
		
		var n = other.denominator * this.numerator;
		if (other.numerator < 0){ // set the sign in the final numerator 
			n = -n;
		}
		return symplify(
				 n,
				 this.denominator * other.numerator.abs()
		);
	}
	
	public isZero() : Boolean {
		return this.numerator.isZero();
	}

	public isOne() : Boolean{
		return this.numerator.equalsTo(denominator);
	}

	public symmetric() : Real {
		return new Rational(numerator.symmetric(), denominator);
	}
	
	public signum() : Integer {
		return numerator.signum();
	}

	public asInteger() : Integer {
		return this.numerator \ this.denominator;
	}

    public isWhole() : Boolean {
    	return this.numerator % this.denominator == 0;
    }
    
    public raiseTo(exponent : Real) : Real {
    	if (this == 0){ 
    		if (exponent == 0){
    			return new Rational(1,1);
    		}
            return this;
        } else if ( this == 1) {
        	return this;
        } else if ( exponent == 0) {
        	return new Rational(1,1);
        } else if (exponent.isWhole()){
            let p : Integer = exponent.asInteger();
            let n : Natural = p.abs();
            var result : Rational = new Rational(this.numerator ^^ n, this.denominator ^^ n);
            if (p < 0) {
                result = result.invert();
            } 
            return result;
        } else {
        	let n = this.numerator ^^ exponent;
        	let d = this.denominator ^^ exponent;
        	
        	if (n.isWhole() && d.isWhole()){
        		return new Rational( n.asInteger() , d.asInteger());
        	}

            return n/ d;
        }
    }

	public invert () : Rational {
		return new Rational(this.denominator * 1Z, this.numerator.abs());
	}
	
	public abs() : Real {
	  var n = this.numerator;
	  if (n < 0 ){
	  	n = -n;
	  }
	  
	  return new Rational(n, this.denominator);
    }
}