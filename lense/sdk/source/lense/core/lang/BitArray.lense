
import lense.core.lang.Binary;
import lense.core.lang.Boolean;
import lense.core.collections.Array;
import lense.core.math.Natural;
import lense.core.lang.Void;
import lense.core.lang.String;
import lense.core.math.Integer;
import lense.core.lang.HashValue;

public class BitArray implements Binary {

	private let bits: Array<Boolean>; // TODO compiler must used this variable for primary constructor and not init it

	public implicit constructor ( private bits: Array<Boolean>); // TODO after removing explicit property , the compiler assumes Array<Array>

	public constructor (bitCount: Natural){
		return new BitArray(new Array<Boolean>(bitCount, false));
	}
	
	public constructor ( bitCount: Natural,  seed: Boolean){
		return new BitArray(new Array<Boolean>(bitCount, seed));
	}
	
	public implicit constructor ( binary: Binary){
		let array : Array<Boolean> = new Array<Boolean>(binary.size, false); // TODO remove left side typing
		
		for (i in 0 ..< binary.size){
			array[i] = binary.getBitAt(i);
		}
		
		return new BitArray(array);
	}

	public flip( index: Natural): Void{
		this.bits[index] = !this.bits[index];
	}
	
	public rightShiftBy( n: Natural): BitArray{
		let newSize = bits.size &- n;

		let newArray = new Array<Boolean>(newSize, false); 

		this.bits.copyTo(newArray, n, 0, newSize);

		return new BitArray(newArray); 
	}
	
	public leftShiftBy(n : Natural) : BitArray{
		let newArray = new Array<Boolean>(bits.size + n, false); 

		this.bits.copyTo(newArray, 0, n, bits.size);
 
		return new BitArray(newArray); 
	}
	
	public flipAll() : Binary {
		let  negated : Array<Boolean> = bits.duplicate();

		for (n in negated.indexes){
			negated[n] = !negated[n];
		}
		
		return new BitArray(negated);
	}	
	
	public equalsTo(other: Any) : Boolean{
		return other is BitArray && other.bits.equalsTo(this.bits);
	}

	public hashValue():  HashValue {
		return bits.size.hashValue();
	}
	

	public size : Natural {
		get{
			return bits.size;
		}
	} 
	
	public [ index: Natural] : Boolean{
		get {
			return bits[index];
		}
		set(value) {
			bits[index] = value;
		}
	}
	
	public getBitAt( index: Natural) : Boolean {
		return this[index];
	}
	
	public asString() : String {
		return this.bits.asString();
	}

}