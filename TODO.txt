Lense CLI
	compile (DONE)
	run 
	test
	document
Change 
	Iterator methods to move and current (DONE)
	+ string operator to ++ => needs resolution on the increment/decrement operator issue [SYNTAX]  (DONE)
	** operator to ^^ [SYNTAX] (DONE) 
Commons patterns like :
		"real + imaginary" to "new Complex(real,imaginary)"
		1/x to x.invert();
Indexes
	allow more than one parameter (DONE)
Named Parameters and Default Parameters
	- allow for calling functions with names   go ( from: x, to : y) is the same as go (to: y ; from: x) [SYNTAX]
	- allow for defining default values in the argument so the parameter is not mandatory    [SYNTAX]
			define print ( msg : String : printer : Printer = defaultPrinter)
			call as print("hello") or as print("hello", myPrinter);
Traits
	interfaces accept default methods. Can be simulated as invocation with static methods or inline in javascript
	a keyword may be used to deferenciate abstract methods from the ones that are defaults. this correlates to the inheritance structure. use default keyword (DONE)
	inheritance structure shoud be closed/final by default (DONE)
Meta Types and meta Interfaces 
	meta types can be defined explicitly and implements meta interfaces
	Operators correlate to predefined meta interfaces
	meta interfaces cannot be implemented by objects but can be used as a type in a parameter or generic and in a instanceof (althout may be not in auto cast)
Erase
	Add numeric limit verification (DONE for ranges)
	Maybe<Boolean> to java.Boolean
	String and String? 
	Errasue of primitive numbers inside limits (needs limit verification)
Imutability
	save flag as an annotation, handle as a meta interface
Generics
 	Add generic signatures to constructors [SYNTAX]
	Capture generics locally (when calling constructors and methods) (DONE)
	Pass capture to methods and constructors (DONE)
	T extends X , T super X [SYNTAX]
	resolve generics problem of adding list to a list (and a sequence to a sequence)
	Generate GenericSignatures (DONE)
	Need GenericType lock to the classe type or method generic defenition
Flow Sensitive Typing
	if (DONE)
	switch
	assert (DONE)
Deconstructing
Difference between val and var [DESIGN]
	change val to let maintain var (DONE)
	make let the default when not explicit inclusive in method parameters to avoid redefining (DONE)
	
Tuples (BNF) and void
	() === void
	call methods on void 
	void inside collections
	
Implement Properties 
	there are n fields in source code 
	implict get and set (DONE)
	in interfaces (DONE)
	validate all non nullable properties are inicialized
	do delegation    size {get = list.size}   or size => list.size (DONE)
Types
	inference and optional typing
	infere optional ": Void" for methods return (DONE)
	generic types of generic types T<U>
Reification
	Generics in types (DONE)
	generics in methods (DONE)
	generics in free methods 
	generics on enancements
	Expression<func>
Reflection
	Type<T> class (DONE)
	typeof operator , like Type t =  typeof(T) [SYNTAX]
	is operator (DONE)
	after testing for type auto cast variable (create a new scope to shadow previous variable)
		inside && (DONE)
		inside || 
		inside IF (DONE)
		inside While
Imports
	detected non existing imports -> depends on finding by name, ignoring parametric types (DONE)
	use naming to find types. discard parametric type count
Auto-package
	accept classes in lense.core automatically 
	accept classes in the same module automatically
Constructors 
	-rethink the static stategy
	- delegation (DONE)
	- delegation when super returns a differnet type of object 
	- inicialization
	- auto- declare properties and fields  (DONE)
Module 
	Module detection and import 
	Module Repositories
Operators and Operacional Interfaces	
	- operator for rational division / (DONE)
	- operator for integer division \ , consistent with % operator D = d * q + r where q = D \ d and r = D % d; (DONE)
	- handle comparable operators with Comparable<T> (DONE)
	- implement exists x as a flow sensitive way to decapsulate Maybe similar to instanceof 
		if (exists x) {  x.do()  }  == transforms to ==> if (x.isPresent) { x' = x.Value ; x'.do() } 
		return exists x;  == transforms to ==> return x.hasValue()
		OR implement if (x != none) == transforms to ==> if (x.isPresent) { x' = x.Value ; x'.do() } BETTER because as no more keywords
	- comparison operators compositions e.x: if (2 < x() <= 10)  == transforms to ==> if ( y = x();  2 < y && y <= 10) simplify if x is not a function if (2 <x && x < 4)
		- rewrite if ( x() in |(2 , 10 ]|) as if (2 < x() <= 10) in the case of numbers
Operators
	?.  [SYNTAX]
	+ , - , *  ==> these will scale ad infinitum (DONE)
	/ always return elements of |Q , |R or |C    N/N , Z/Z , N/Z, Z/N , Q,Q -> Q , Q/R, R/Q, R/R -> R, x/C or C/x = C (DONE)
	>> , << (Binary) (DONE)
	& , | , ^ (DONE)
	^^ (Exponenciable) pow() (DONE)
	+= ,*= (ok, auto  a += n <==> a = a + n and  a *= n <==> a = a * n  
    -=, /= (only for some kinds  nat a = 2 , a -= 1 (ok); a-= 1(ok) ; a-= 1 (error);
	++ , -- (Ordinal) successor() and predecessor() (DONE)
	&+, &- , &*, &/ ==> these will wrap around silently (java default)^
	?+, ?- , ?*, ?/ ==> these will return Maybe<T> with None value when overload appends
	!+ , !- , !*, !/ ==> thee do exact operation and throw OverflowException <=>AddExact, SubtractExact, MultiplyExact.
	
	- (symmetric) closed for all except natural. Natural.symmetric():Integer (DONE)
	
	i++ and i-- this operators implies in tree rewrite of on node by a collection of nodes. are statements, not expressions. 
	equivalent to a = a.sucessor() and a = a.predecessor();

	In32.max.sucessor = In32.max; (warp)
	In32.max !+ 1 := Int32.max.exactPlus((Integer)1) -> OverflowException(). this does AddExact
	In32.max &+ 1 := Int32.max.wrapPlus(1) == Int32.min                Int32.wrapPlus(Int32):Int32
	In32.max ?+ 1 := In32.max.checkPlus(1) == none              Int32.checkPlus(Int32):Maybe<Int32>
	In32? result = 2 ?+ In32.max ?+ 2   ==>  new Some(2).map( a -> a.checkPlus(Int32.max)).map(b -> b.checkPlus(2) )
	
	Super Numbers , BigInt and Natural do not throw exception, nor warp, or overflow. They increase as needed (default) (DONE)
	
	BigInt max = Int32.max; // same as BigInt max = BigInt.valueOf(Int32.max)
	BigInt next = max + 1; // BigInt next = max.plus(BigInt.valueOf(Natural(1)))
	BigInt aftermax = In64.valueof(Int32.max) + 1  // BigInt.valueOf( In64.valueOf(Int32.max).plus(Natural(1)))
	Assert.AreEqual(aftermax, next);

Native implementations weaving
	 - native types (DONE) 
	 - native peers
	 - native import like :  import native (js) jquery;
	 - native = call to subjacent plataform api
Case classes and objects
    - Object (DONE)
    - Enum (DONE via sealed types)
    - Annotation
    - Enhancements -> usefull for operations on numbers of different types. enhancements can be native
	- case classes,  (DONE via algebric types)
	- case objects   (DONE via algebric types)
	- data classes 
	- value classes
	- (sealed) sum types like: class Boolean is true | false; (DONE)
Revisit ordering of elements in class body.
	- it should not matter
Revisit Fields  not initialized 

Allow module to have any name
	-place module.lense in source root folder
	-allow for package in files as optional. (DONE) 
		if present validate it matches the folder structure 
Ad elvis operator since transparent maybe is no good ?:
    List<String>? maybeList = ...
    maybeList.map( a -> a) <---- accessing maybe.map, a is a list
    maybeList.hasValue
    maybeList?.map( a -> a) <----- accessing list.map, a is a string
    maybeList?size <----- accessing list.size
    maybeList?[1] <----- accessing list[1]
    
    or 
    
    maybeList@map( a -> a) <---- accessing maybe.map, a is a list
    maybeList@hasValue
    
    maybeList.map( a -> a) <----- accessing list.map, a is a string
    maybeList.size <----- accessing list.size
    maybeList[1] <----- accessing list[1]
    
    or 
    
    maybeList:map( a -> a) <---- accessing maybe.map, a is a list
    maybeList:hasValue
    maybeList.map( a -> a) <----- accessing list.map, a is a string
    maybeList.size <----- accessing list.size
    maybeList[1] <----- accessing list[1]
    
Literals
	- Progression : 1...3 => 1.upTo(3)
	- Interval :  |[ , )| operators (DONE)
	- all whole numeric literals are natural numbers (DONE)
	- all fractional numeric literals are rational numbers (DONE)
	- imaginary unit is 'i' and 2i means  Rational("2") * Complex.I; (DONE)
	 
	 
	 intervals literal (DONE)
	 sequence literals [1,2,3,4]  (DONE)
	 map literals { "a": 1, "b": 2 , "c" : 3} (DONE)
     Builders like Window { Size = Size { 20, 40} }} equivalente to new : xml alternative + parser
	 Property bag as single loadable/parsable file (JSON style) 

Callable
	Functions<R, T...> are subtypes of Callable<R, Tuple<T, Tuple<T...>>>
	Have method R call([T...] paramsTuple)
	Have a method 'after' for composition f o g =>  f.after(g) => f(g(x))
	Have a method 'then' for composition f o g =>  g.then(f) => f(g(x))
 
Meta 
	- memorize declaring type (specially if implementing interface)
Static reading
	- Differentiate objects from types
	- Differentiate methods called on objects (e.x: Console.print) from methods called on companion object, from calls to constructors.
	Interperter calls like "Console.println" as "Console.Companion.println"
		in java "Companion" is a static field in "Console". Companion is a singleton but is not a singleton of the given class. it was its own class.
		Alternativly "Console" is the name of an object. In this case if "console" exists in package lang.io there will be a class named "IO$Package" and
		static field of type Console on it so "Console.println" would be IO$Package.Console.println" 

Maybe<T> cannot be Maybe<Maybe<T>> . What appends if T <: Any and Maybe<T> <: Any ?
	Introduce more super types in the hierarchy. Consider renaming  Maybe<T> to Reference<T> 
			Any 
				AnyObject : can be any object
					User defined types inherit from  Object by default unless the programmer explicits otherwise.
				Maybe<V extends AnyObject>  : can be Some<V> or None. This structure proibits Maybe<Maybe<A>> since Maybe is not an AnyObject
			Nothing	
			
			This structure can poibit to have some methods like, in a Map<AnyObject K, AnyObject V> with method get(K key ): Maybe<V> 
			is impossible to have  Map<AnyObject K , Maybe<V> > since Maybe is not AnyObject
			This means the key cannot be present without the valor. If  map.contains(key) is true, then is also true the value exists and is not None. 
		
Lambdas
     - how to compile 
     - handle Single Abstract Method types
     - validate variables used are effectively final
Monads
	 monads are structural (have filter, map and flatmap) because of unit but can use exentions + Functor<T> interface
	 Promisses   do (something) then (something) else (otherthing)
	 Maybe
	 Collection (aka Enumerable)

Understanding
	 Methods are wrappers arround functions because they curry arround 'this'. static types do not curry
	  constructors are curried Actions like constructor.apply(this): Void. 
Insight 
	 Ceylon does not have new keyword, but forces classes to pascal case !!	
	 Language should help comunication and documentation.   
	 New should be replaces by static method factory. => Maybe methods in meta classes
Imutability
	 value classes :  public val class Rational , to mean the class is imutable. properties must also be val or only have methods
	 value classes are "primitives" and can be safely shared by actors: actor.send(message). Message must be imutable or seriablizable.
	 Mark interfaces Imutable and Serializable and have : class Actor {   Void send<T extends Imutable | Serializable>(T msg)  }
	 
	 Constructors, companions, and methods vs functions and apply.  Client("A") <=> Client.apply("A") <=> Client.Companion.apply("A")
Scala way of "all are functions" collapses the Collections variance intuition becasue functions are contravariant 
	and collections concepts are covariant the result is an invariant collections api
	http://www.stackoverflow.dluat.com/questions/676615/why-is-scalas-immutable-set-not-covariant-in-its-type	 
R/R (Compiler)
	revise reduce-reduce conflicts
	
