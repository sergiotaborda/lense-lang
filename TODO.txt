Allow module to have any name
	-place module.lense in source root folder
	-allow for package in files as optional. if present validate it matches the folder structure
Error and Warning Listener
	- add listener of warn and error events. also start and end.
Ad elvis operator since transparent maybe is no good

Confirm 0.5 is parsable as a double
Literals
	- Sequence : { 1, 2, 3,}  => new ImutableNativeSequence(int[] {1,2,3}) 
	- Association : { 1=2, 3=5,7=9} or { 1:2, 3:4, 5:7} //javascript  => new ImutableAssociation( entry(1,2), entry(3,5), entry(7,9))
	- Tuple (1,2,3)  or [1,2,3]  => Tuple.of(1,2,3) => new Tuple<Int, Tuple<Int, Tuple<int,Nothing>>(1 , new Tuple<Int, Tuple<int,Nothing>>(2, Tuple<int,Nothing>>(3, _)))
	- Progression : 1...3 => 1.upTo(3)
	- Interval :  1..3 |  1... | ...3 |  1<..3 |  1..<3 | 1<..<3 => Interval.from(1).inclusive().to(3).inclusive() , etc... 
Use constructors
	- sintax
	- named constructors 
	- restrictions on the use of new operator outside constructors.
	- promote using constructors.
Static reading
	- Differenciate objects from types
	- Differenciate methods called on objetcs (e.x: Console.print) from methods called on companion object, from call to constrcutors.
	Interperter calls like "Console.println" as "Console.Companion.println"
		in java "Companion" is a static field in "Console".
		Alternativly "Console" is the name of an object. In this case if "console" exists in package lang.io there will be a classe named "IO$Package" and
		static field of type Console on it so "Console.println" would be IO$Package.Console.println" 
Generics
	Need GenericType lock to the classe type or method generic defenition
	
	Diferenciate ReferenceType and TypeVar 
	ReferenceType = ClassOrInterfaceType | ArrayType
	
	to
	
	ReferenceType = ClassOrInterfaceType | ArrayType | TypeVar
	TypeVar = Identifier
	ClassOrInterfaceType = ClassOrInterface { < TypeParameters > }
	ClassOrInterface = Identifier | ClassOrInterfaceType . Identifier
Maybe<T> cannot be Maybe<Maybe<T>> . What appends if T <: Any and Maybe<T> <: Any ?
	Introduce more super types in the hierarchy. Consider renaming  Maybe<T> to Reference<T> 
			Any 
				AnyObject : can be any object
					User defined types inherit from  Object by default unless the programmer explicits otherwise.
				Maybe<V extends AnyObject>  : can be Some<V> or None. This structure proibits Maybe<Maybe<A>> since Maybe is not an AnyObject
			Nothing	
			
			This structure can poibit to have some methods like, in a Map<AnyObject K, AnyObject V> with method get(K key ): Maybe<V> 
			is impossible to have  Map<AnyObject K , Maybe<V> > since Maybe is not AnyObject
			This means the key cannot be present without the valor. If  map.contains(key) is true, then is also true the value exists and is not None. 
		
Lambdas
     - how to compile 
     - handle Single Abstract Method types
     - validate variables used are efectively final
Monads
	 monads are structural (have filter, map and flatmap) because of unit but can use exentions + Monad<T> interface
	 Promisses   do (something) then (something) else (otherthing)
	 Maybe
	 Collection (aka Enumerable)
Properties	 
	 public String Name { get {} set (String value){   } }
	 public Name : String { get {} set ( value : String){   } }
	 public Name : String { get {} set ( value ){   } }
UAP	 
	 parentesis are optional for zero arguments methods.  fields == methods == properties, decide by name and uniquencess ?!
     - maybe is not possible 
Native	 
	 Peer classes and native
	 native import ?
	 native = call to subjacent plataform api. this must be 
Meta-Compiler	
	 compiler plugins and delegation sintax  Regex<| ashdads |> = is ungly, but it would be cool to have some way to write , and have auto-promotion
	 		Color color = #3AF90;
	 But preferably without implicits
	 Optional parameters vs overloading vs generics vs compatability with javascritpt
More literals	 
	all numeric literals are rational numbers
	 imaginary unit is 'i' and 2i means  Rational("2") * Complex.I;
	 literals for urls (?) - resolved with implicits
	 literals for regex - resolved with implicits
	  intervals literal
	 list and map literals (javascript like)
	 	list = new List {"a","b","c"} 
		 map = new HashMap { "a": 1, "b": 2 , "c" : 3} 
     Builders like Window { Size = Size { 20, 40} }} equivalente to new : xml alternative + parser
	 Property bag as single loadable/parsable file (JSON style) 
Operatores and Operacional Interfaces	
	 operator for racional division 	
Comparable
	- handle comparable operators
Tuples
	 Because of reification Tuple is diferent from Tuple<A> and diferente from Tuple<A,B> , etc...
	 Resolve problem with a classe for each rank. rank 0 is equivalent to void
	 	[]  =>		Tuple === Void
	    [A]	=>		Tuple<A> => Tuple<A , Void>
	 	[A,B] =>	Tuple<A,B>  => Tuple<A, Tuple<B, Void>>
	 	[A,B,C] =>	Tuple<A,B,C> => Tuple<A, Tuple<B, Tuple<C, Void>>
	 	[A,B,C,D] =>Tuple<A,B,C, D> => Tuple<A, Tuple<B, Tuple<C, Tuple<D,Void>>
	 
	 	class Tuple 
	 		// protected contructor 
	 		// no methods, because as no value
	 		
	 	class Tuple<H, T extends Tuple> extends Tuple
	 		.Head : H
	 		.Tail : T
	 		.get(Natural i);
	 		.constructor (H, T);
	 		
	 	class Void extends Tuple
	 		// no methods

	 	interface Tuple<T, N> 
	 	    first: T;
	 	    next : N; 
	 	    
		class Pair<A,B> implements Tuple<A,B>
			last : B	 	    
	 	    
	 Void = Tuple de argumento nenhum
	 	
	 	class Void implements Tuple<Nothing, Nothing>
	 	object Void extends Void;
	 	
	 [a, b,c] short notation
	 A tuple with all types equal is a sequence

	 sintax sugar tuple[0] em vez de tuple.item1  
	 
	 	tuple[0] => tuple.first;
	 	tuple[1] => tuple.next.first;
	 	tuple[2] => tuple.next.next.first;
	 
Reification and Generics
	 resolve generics problem of adding list to a list (and a sequence to a sequence)
Understanding
	 Methods are wrappers arround functions because they curry arround 'this'. static types do not curry
	  constructors are curried Actions like constructor.apply(this): Void. 
Insight 
	 Ceylon does not have new keyword, but forces classes to camel case !!	
	 Language should help comunication and documentation.   
	 New should be replaces by static method factory. Can be used insi
Imutability
	 value classes :  public val class Rational , to mean the class is imutable. properties must also be val or only have methods
	 value classes are "primitives" and can be safely shared by actors: actor.send(message). Message must be imutable or seriablizable.
	 Mark interfaces Imutable and Serializable and have : class Actor {   Void send<T extends Imutable | Serializable>(T msg)  }
	 
	 Constructors, companions, and methods vs functions and apply.  Client("A") <=> Client.apply("A") <=> Client.Companion.apply("A")
Scala way of "all are functions" collapses the Collections variance intuition becasue functions are contravariant 
	and collections concepts are covariant the result is an invariant collections api
	http://www.stackoverflow.dluat.com/questions/676615/why-is-scalas-immutable-set-not-covariant-in-its-type	 
Compilation 	 
	 read compilation metadata from .class
	 definition of a classpath = project structure for compiler (maven like)
	 	project XYZ
	 		source 
	 			Module.lense
	 			org
	 				XYZ  
	 					packageA
	 						X.lense
	 					packageB
	 						Y.lense
	 						Z.lense
	 		compilation
	 			java
	 				bin
	 					XYZ.jar 
				js
					bin
						XYZ.module.js
	 		
	
