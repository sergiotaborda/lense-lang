Indexes
	allow more than one parameter (DONE)
Tuples (BNF) and void
	() === void
	call methods on void
Implement Properties 
	in interfaces (DONE)
	validate all non nullable properties are inicialized
	do delegation    size {get = list.size}   or size => list.size

Types
	inference and optional types
	infere optional : Void for methods (DONE)
Reflection
	Type<T> class
	typeof operator
	is operator (DONE)
	after testing for type auto cast variable (create a new scope to shadow previous variable)
		inside && (DONE)
		inside || 
		inside IF (DONE)
		inside While
Imports
	detected non existing imports -> depends on finding by name, ignoring parametric types
	use naming to find types. discard parametric type count
R/R (Compiler)
	revise reduce-reduce conflicts
Constructors 
	-rethink the static stategy
	- delegation
	- inicialization
	- auto- declare properties and fields  (DONE)
Auto-package
	accept classes in lense.core automatically 
	accept classes in the same module automatically
Generics
 	Add generic signatures to constructors
	Capture generics locally (when calling constructors and methods with free generics)
	Pass capture to methods and constructors
	T extends X , T super X
	resolve generics problem of adding list to a list (and a sequence to a sequence)
Operators
	?.
	+ , - , *  ==> these will throw OverflowException  <=> AddExact, SubtractExact, MultiplyExact.
	/ always return elements of |Q , |R or |C    N/N , Z/Z , N/Z, Z/N , Q,Q -> Q , Q/R, R/Q, R/R -> R, x/C or C/x = C
	>> , << (Binary)
	& , | , ^
	** (Exponenciable) pow()
	+= ,*= (ok, auto  a += n <==> a = a + n and  a *= n <==> a = a * n
    -=, /= (only for some kinds  nat a = 2 , a -= 1 (ok); a-= 1(ok) ; a-= 1 (error);
	++ , -- (Ordinal) successor() and predecessor() (DONE)
	&+, &- , &*, &/ ==> these will wrap around silently (java default)
	?+, ?- , ?*, ?/ ==> these will return Maybe<T> with None value when overload appends
	- (symmetric) closed for all except natural. Natural.symmetric():Integer (DONE)
	
	i++ and i-- this operators imply in tree rewrite of on node by a collection of nodes. are statements, not expressions. 
	equivalent to a = a.sucessor() and a = a.predecessor();

	In32.max.sucessor = In32.max; (warp)
	In32.max + 1 := Int32.max.plus((Integer)1) -> OverflowException(). this does AddExact
	In32.max &+ 1 := Int32.max.wrapPlus(1) == Int32.min                Int32.wrapPlus(Int32):Int32
	In32.max ?+ 1 := In32.max.checkPlus(1) == none              Int32.checkPlus(Int32):Maybe<Int32>
	In32? result = 2 ?+ In32.max ?+ 2   ==>  new Some(2).map( a -> a.checkPlus(Int32.max)).map(b -> b.checkPlus(2) )
	
	Super Numbers , BigInt and Natural do not throw exception, nor warp, or overflow. They increase as needed (default) (DONE)
	
	BigInt max = Int32.max; // same as BigInt max = BigInt.valueOf(Int32.max)
	BigInt next = max + 1; // BigInt next = max.plus(BigInt.valueOf(Natural(1)))
	BigInt aftermax = In64.valueof(Int32.max) + 1  // BigInt.valueOf( In64.valueOf(Int32.max).plus(Natural(1)))
	Assert.AreEqual(aftermax, next);

Native implementations weaving
	 - native types (DONE) 
	 - native peers
	 - native import like :  import native (js) jquery;
	 - native = call to subjacent plataform api
Case classes and objects
    - Object (DONE)
    - Enum
    - Annotation
	- case classes, 
	- case objects 
	- data classes 
	- value classes
	- sum types like   Boolean is true | false;
Revisit ordering of elements in class body.
	- it should not matter
Revisit Fields  not initialized 
Operators and Operacional Interfaces	
	- operator for rational division /
	- operator for integer division \ , consistent with % operator D = d.q + r where q = D \ d and r = D % d;
	- handle comparable operators with Comparable<T>
Allow module to have any name
	-place module.lense in source root folder
	-allow for package in files as optional. if present validate it matches the folder structure
Ad elvis operator since transparent maybe is no good ?:
    List<String>? maybeList = ...
    maybeList.map( a -> a) <---- accessing maybe.map, a is a list
    maybeList.hasValue
    maybeList?.map( a -> a) <----- accessing list.map, a is a string
    maybeList?size <----- accessing list.size
    maybeList?[1] <----- accessing list[1]
    
    or 
    
    maybeList@map( a -> a) <---- accessing maybe.map, a is a list
    maybeList@hasValue
    
    maybeList.map( a -> a) <----- accessing list.map, a is a string
    maybeList.size <----- accessing list.size
    maybeList[1] <----- accessing list[1]
    
    or 
    
    maybeList:map( a -> a) <---- accessing maybe.map, a is a list
    maybeList:hasValue
    maybeList.map( a -> a) <----- accessing list.map, a is a string
    maybeList.size <----- accessing list.size
    maybeList[1] <----- accessing list[1]
    
Literals
	- Progression : 1...3 => 1.upTo(3)
	- Interval :  |[ , )| operators (DONE)
	- all whole numeric literals are natural numbers (DONE)
	- all fractional numeric literals are rational numbers (DONE)
	- imaginary unit is 'i' and 2i means  Rational("2") * Complex.I; (DONE)
	 
	 
	 intervals literal
	 sequence literals [1,2,3,4]  DONE
	 map literals { "a": 1, "b": 2 , "c" : 3} (DONE)
     Builders like Window { Size = Size { 20, 40} }} equivalente to new : xml alternative + parser
	 Property bag as single loadable/parsable file (JSON style) 


Callable
	Functions<R, T...> are subtypes of Callable<R, Tuple<T, Tuple<T...>>>
	Have method R call([T...] paramsTuple)
	Have a method 'after' for composition f o g =>  f.after(g) => f(g(x))
	Have a method 'then' for composition f o g =>  g.then(f) => f(g(x))
 
Meta 
	- memorize declaring type (specially if implementing interface)
Static reading
	- Differentiate objects from types
	- Differentiate methods called on objects (e.x: Console.print) from methods called on companion object, from calls to constructors.
	Interperter calls like "Console.println" as "Console.Companion.println"
		in java "Companion" is a static field in "Console". Companion is a singleton but is not a singleton of the given class. it was its own class.
		Alternativly "Console" is the name of an object. In this case if "console" exists in package lang.io there will be a class named "IO$Package" and
		static field of type Console on it so "Console.println" would be IO$Package.Console.println" 
Generics
	Generate GenericSignatures (DONE)
	Need GenericType lock to the classe type or method generic defenition
	
	Diferenciate ReferenceType and TypeVar 
	ReferenceType = ClassOrInterfaceType | ArrayType
	
	to
	
	ReferenceType = ClassOrInterfaceType | ArrayType | TypeVar
	TypeVar = Identifier
	ClassOrInterfaceType = ClassOrInterface { < TypeParameters > }
	ClassOrInterface = Identifier | ClassOrInterfaceType . Identifier
Maybe<T> cannot be Maybe<Maybe<T>> . What appends if T <: Any and Maybe<T> <: Any ?
	Introduce more super types in the hierarchy. Consider renaming  Maybe<T> to Reference<T> 
			Any 
				AnyObject : can be any object
					User defined types inherit from  Object by default unless the programmer explicits otherwise.
				Maybe<V extends AnyObject>  : can be Some<V> or None. This structure proibits Maybe<Maybe<A>> since Maybe is not an AnyObject
			Nothing	
			
			This structure can poibit to have some methods like, in a Map<AnyObject K, AnyObject V> with method get(K key ): Maybe<V> 
			is impossible to have  Map<AnyObject K , Maybe<V> > since Maybe is not AnyObject
			This means the key cannot be present without the valor. If  map.contains(key) is true, then is also true the value exists and is not None. 
		
Lambdas
     - how to compile 
     - handle Single Abstract Method types
     - validate variables used are efectively final
Monads
	 monads are structural (have filter, map and flatmap) because of unit but can use exentions + Functor<T> interface
	 Promisses   do (something) then (something) else (otherthing)
	 Maybe
	 Collection (aka Enumerable)

Understanding
	 Methods are wrappers arround functions because they curry arround 'this'. static types do not curry
	  constructors are curried Actions like constructor.apply(this): Void. 
Insight 
	 Ceylon does not have new keyword, but forces classes to pascal case !!	
	 Language should help comunication and documentation.   
	 New should be replaces by static method factory. Can be used insi
Imutability
	 value classes :  public val class Rational , to mean the class is imutable. properties must also be val or only have methods
	 value classes are "primitives" and can be safely shared by actors: actor.send(message). Message must be imutable or seriablizable.
	 Mark interfaces Imutable and Serializable and have : class Actor {   Void send<T extends Imutable | Serializable>(T msg)  }
	 
	 Constructors, companions, and methods vs functions and apply.  Client("A") <=> Client.apply("A") <=> Client.Companion.apply("A")
Scala way of "all are functions" collapses the Collections variance intuition becasue functions are contravariant 
	and collections concepts are covariant the result is an invariant collections api
	http://www.stackoverflow.dluat.com/questions/676615/why-is-scalas-immutable-set-not-covariant-in-its-type	 

	
