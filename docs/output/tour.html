<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Tour</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">
    
    
  
	<script src="js/shCore.js"></script>

	<script src="js/shBrushScala.js"></script>
	<script src="js/shBrushCSharp.js"></script>
	<script src="js/shBrushDart.js"></script>
	<script src="js/shBrushJava.js"></script>
		
	<script src="js/shBrushLense.js"></script>
	<style>
	 .console {
	    background : black;
	    color: white;
	    width: 500px;
	 }
	 p {
	 	text-align:justified;
	 }
	 pre {
	 	background-color:white !important;
	 	border:0px !important;
	 	padding:0px !important;
	 	overflow: visible !important;
	 }
	 pre code {
	 	padding:2px !important;
	 	margin : 0px !important;
	 }
	</style>

    <!-- Le styles -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/asciidoctor.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">
  	<link rel="stylesheet" type="text/css" href="css/shCore.css"  >
	<link rel="stylesheet" type="text/css" href="css/shThemeLense.css" >
	
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">Lense</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="news.html">News</a></li>
            <li><a href="download.html">Download</a></li>
            <li><a href="documents.html">Documentation</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Development<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="https://github.com/sergiotaborda/lense-lang">Source Code</a></li>
                <!--
                <li><a href="#">Another action</a></li>
                <li><a href="#">Something else here</a></li>
                <li class="divider"></li>
                <li class="dropdown-header">Nav header</li>
                <li><a href="#">Separated link</a></li>
                <li><a href="#">One more separated link</a></li>
                -->
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Content<b class="caret"></b></a>
              <ul class="dropdown-menu">
                	<li><a href="concurrency.html">Concurrency</a></li>
                	<li><a href="sumtypes.html">Sum Types</a></li>
                	<li><a href="containerLiterals.html">Container Literals</a></li>
                	<li><a href="documents.html">Documentation</a></li>
                	<li><a href="objects.html">Objects</a></li>
                	<li><a href="constructors.html">Constructors</a></li>
                	<li><a href="enhancements.html">Enhancements</a></li>
                	<li><a href="index.html">Home</a></li>
                	<li><a href="tour.html">Tour</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
	<p><h1>Hello, world !</h1><p>This is our version of the quintessential <em>Hello, world program</em>.</p>
<pre><code class="brush: lense">	public class Hello extends ConsoleApplication {
	
		public run (){
			Console.print(&quot;Hello, world!&quot;);
		}
	}
</code></pre><p>Prints</p>
<blockquote><p>Hello, world!</p>
</blockquote><p>We define a class <code>Hello</code> than extends the <code>ConsoleApplication</code> class provided in the SDK. This makes the Hello class a executable entry point.<br/>The class can have any name. The entry method is run(). The VM will instantiate the class, set the Arguments property according to the platform parameters and execute the run method;<br/>The method makes use of the print method in the Console object. The Console object is a SDK provided object that allows interaction with the console. Note the method does not declare any parameters or return type.<br/>The return type is only needed when the compiler could not infer it. In this case the method run is defined in the ConsoleApplication class so the compiler can infer from the base declaration the return is Void.<br/>There is no "void" reserved word. Void is a type like any other. </p><p>The print method simply print the given String literal to the console. You can see a string is declared enclosing the text in double quotes. String literals preserve line breaks and tabulation</p>
<pre><code class="brush: lense"><br/>public class Hello extends ConsoleApplication {

	public run () {
		Console.print(&quot;Hello,
						world!&quot;);
	}
}

</code></pre><p>Prints</p>
<pre><code class="console">Hello,						
 					world!  
</code></pre><h3>Escape Sequences</h3><p>Strings support unicode, and unicode characters can be embedded using the { } escape sequence that receives an Hexadecimal value.<br/>Also, Strings can be interpolated using he {{ }} escape sequence. Any expression can be use inside the interpolation sequence and its string representation will be printed (by calling the toString() method on the result of the expression).</p>
<pre><code class="brush: lense">public class Hello extends ConsoleApplication {

	public run () {
		Decimal pi = 3.1415; 
		Console.print(&quot;Hi!, the mathematical constant \{#03C0} is {{ pi }}  &quot;);
	}
}

</code></pre><p>Prints</p>
<blockquote><p>Hi!, the mathematical constant &pi; is 3.1415</p>
</blockquote><p>You can notice that #03C0 denotes an hexadecimal number.</p><h2>Nullability</h2><p>Null references are not allowed , but the notion of an absent value is very useful.</p>
<pre><code class="brush: lense">public class Hello extends ConsoleApplication {

	public run (){
		
		Console.print(&quot;Hi!, the first argument is {{ Arguments.first() }}.&quot;);
	}
}

</code></pre><p>Prints</p>
<blockquote><p>Hi!, the first argument is null.</p>
</blockquote><p>"Arguments" is a read only property of ConsoleAplication that was set with the arguments passed in the console at the momento of running the application.<br/>With can access the first element of the arguments sequence by invoking the first() method. The first argument in arguments might not be present, the arguments sequence may be empty.<br/>So in this case, in other languages, null would be returned and printed. lense does not have null references, but "null" is printed nontheless. How is that ?</p><p>Well, left look closer to the return of <code>first</code></p>
<pre><code class="brush: lense">public class Hello extends ConsoleApplication {
	public run () {
		val String? argument = Arguments.first();
		Console.print(&quot;Hi!, the first argument is {{ argument }}.&quot;);
	}
}

</code></pre><p>The type returned by the <code>first</code> method is a <code>Maybe&lt;String&gt;</code>. That why there is a ? after <code>String</code>. String is<br/>the type of elements contained inside the <code>Arguments</code> sequence. <code>Maybe&lt;T&gt;</code> is a generic types class that allows for only two subclasses : <code>Some&lt;T&gt;</code> and <code>None</code>. <code>Some&lt;T&gt;</code> contains some object of type T, and <code>None</code> does not contain any value.</p><p>If a value is present the class <code>Some&lt;T&gt;</code> is instantiated with that value, if not, an instance of None is returned.<br/>However None has only one instance: the <code>none</code> object. The <code>none</code> object itself overrides the <code>toString</code> method to return the word 'null'. Also 'null' is a reserved word in the language<br/>that can used to initialize to an absent value, like: </p>
<pre><code class="brush: lense">	var String? name = null; // we don&#39;t kown the name yet.
	name = &quot;The Name&quot;; // now we kown.
</code></pre><p>The usage is very similar to java and C# and others however is mandatory to declare the variable has maybe absent either explicitly declaring it as <code>Maybe&lt;T&gt;</code> or using the ? suffix abbreviation.<br/>There is a lot of abbreviations and syntax sugar so the transition from other languages is not that rought. We can explicitly write the same has: </p>
<pre><code class="brush: lense">	var Maybe&lt;String&gt; name = Absent; // we don&#39;t known the name yet.
	name = new Some(&quot;The Name&quot;); // now we known.
</code></pre><p>However if we need to have a non absent value we can use the or method, or equivalently the (|) operator</p>
<pre><code class="brush: lense">public class Main {
	public Void main(Array&lt;String&gt; args){
		String? argument = args.first();
		String = argument | &quot;world&quot;; // the same as argument.or(&quot;world&quot;);
		Console.print(&quot;Hi!, the first argument is {{ argument }}.&quot;);
	}
}
</code></pre><p>Prints</p>
<blockquote><p>Hi!, the first argument is world.</p>
</blockquote><h2>Variables and Values</h2><p>In any scope when can define a value</p>
<pre><code class="brush: lense">	val k = 3;
	val u: Int;
	u = 90;
	u = 80; // error!
</code></pre><p>Values are immutable and cannot be changed after initialized. All values need to be explicit initialized before they can be read.<br/>Once again the compiler will infer the type of the value from the initialization expression. If there is no initialization, the declarion of the type is required.<br/>A value can be made mutable by using the <code>var</code> annotation instead of <code>val</code>. An mutable value is called a <i>variable</i>.</p>
<pre><code class="brush: lense">	 var Int n = 1; // inicialize
     n = 2; // ok, n is a variable.
</code></pre><h2>Functions</h2><p>Functions allow for algorithms to be executed before returning a value.<br/>Normally this algorithms depend on parameters that the function declares explicitly.</p>
<pre><code class="brush: lense">	 doSomething() : Void { 
	 	Console.print(&quot;Doing something&quot;);
	 };
	 square (Natural x) : Natural { return x*x; }
</code></pre><p>Functions always return a value. <code>Void</code> is not a keyword is an actual type. <code>Void</code> only has one instance denoted <code>()</code> (the empty tuple). All functions have an implicit return of the instance of <code>Void</code> at the end. This is correct unless the method return other type. You can explicitly write a return of a instance of <code>Void</code>.</p>
<pre><code class="brush: lense">	 doSomething() : Void { 
	 	Console.print(&quot;Doing something&quot;);
	 	return; // implicitly return the instance of Void.
	 };
	 square (Int x) : Int { return x*x; }
</code></pre><p>Functions are objects of type Callable:</p>
<pre><code class="brush: lense">	 Callable&lt;Int, Int&gt; f = x -&gt; x*x;
	 Callable&lt;Int, Int&gt; g = x -&gt; x*2;
	 
	 Callable&lt;Int, Int&gt; h = g.then(f); // the same as f(g(x)) - apply g first, them apply f
	 
	 Console.println(h(2)); // (2*2)*(2*2)
	 Console.println(h(3)); // (3*2)*(3*2)
</code></pre><p>Prints</p>
<pre><code class="console">16						
36						
</code></pre><p>If the internal function returns void, the second applied function cannot have parameters.</p>
<pre><code class="brush: lense">     Callable&lt;Int, Void&gt; f = () -&gt; 2;
	 Callable&lt;Void, Int&gt; g = x -&gt; return; ;
	
	 
	 Callable&lt;Void, Void&gt; h = g.then(f); // the same as f(g(x)) - apply g first, them apply f., but g returns Void, so f must required Void as single argument.
	 
	 Console.println(h(2)); // 2   
	 Console.println(h(3)); // 2
	 
</code></pre><p>This is a complicated way to write the equivalent function:</p>
<pre><code class="brush: lense">     Callable&lt;Int, Void&gt; h = x -&gt; {
     	return 2;
     }
</code></pre><h2>Numbers</h2><p>Numbers are separated in specific algebraic structures that conform to the mathematical rules of the group of elements.<br/>All numbers implement the <code>Number</code> class.</p>
<ul>
  <li>Whole - numbers with no decimal part.
  <ul>
    <li>Natural - Represent elements from the mathematical <strong>N</strong> set, i.e. positive only whole values that include zero and range from zero to an arbitrary range limited only by available memory.</li>
    <li>Integer - Represent elements from the mathematical <strong>Z</strong> set, i.e. negative and positive whole values.
    <ul>
      <li>Int16 - negative and positive whole values with range from -2<sup>16</sup> to 2<sup>16</sup>-1.</li>
      <li>Int32 - negative and positive whole values with range from -2<sup>32</sup> to 2<sup>32</sup>-1.</li>
      <li>Int64 - negative and positive whole values with range from -2<sup>64</sup> to 2<sup>64</sup>-1.</li>
      <li>BigInt - negative and positive whole values with arbitrary range limited only by available memory</li>
    </ul></li>
  </ul></li>
  <li>Real - Represent elements from the mathematical <strong>R</strong> set.
  <ul>
    <li>Rational - Represent elements from the mathematical <strong>Q</strong> set, i.e. rational numbers defined by a natural numerator and a natural denominator like 2/3 or -5/8. The denominator cannot be zero.</li>
    <li>Decimal - Represent elements that have a fixed precision and so calculations may incur in loss of precision.
    <ul>
      <li>Decimal32 - negative and positive decimal values that follow 32 bits IEEE 3744 conventions</li>
      <li>Decimal64 - negative and positive decimal values that follow 64 bits IEEE 3744 conventions</li>
      <li>BigDecimal - Represents elements in the <strong>R</strong> set including truncated version of irrational numbers.Negative and positive decimal values with arbitrary precision limited only by available memory.</li>
    </ul></li>
  </ul></li>
  <li>Imaginary -Represent elements from the mathematical <strong>I</strong> set. Numbers with pure imaginary parts of the form <code>bi</code> where <code>i</code> is the square root of -1.
  <ul>
    <li>ImaginaryOverReals<T extends Real>; - uses a Real type to store the numeric value</li>
  </ul></li>
  <li>Complex - Represent elements from the mathematical <strong>C</strong> set. Complex numbers are of the form <code>a + bi</code> where <code>i</code> it the square root of -1.
  <ul>
    <li>ComplexOverReals<T extends Real>; - Use a Real to type to store a numeric value for the real part and a ImaginaryOverReals<T> for the imaginary part.</li>
  </ul></li>
</ul><p>Whole number literals are always assumed Natural and transformed to other types as needed. This conversion may rise <code>OverflowException</code> as the Natural type was no max value being limited only by memory available (It's like a BigInt with no sign). Decimal values are always assumed as BigDecimal. BigDecimal constructor only accepts a string representation of the value this is because the BigDecimal representation must be exact.</p>
<pre><code class="brush: lense">	var Natural n = 1; // equivalent to Natural.valueOf(&quot;1&quot;)
	var Whole n = 1; // equivalent to Natural.valueOf(&quot;1&quot;)
	
	// literals are always assumed to be Natural and promoted when necessary
	var Int32 i = 1;  // equivalent to Int32.valueOf(Natural.valueOf(&quot;1&quot;));
	var Int16 s = 1;  // equivalent to Int16.valueOf(Natural.valueOf(&quot;1&quot;));
	var Int64 k = 1;  // equivalent to Int64.valueOf(Natural.valueOf(&quot;1&quot;));
	var BigInt g = 1;  // equivalent to BigInt.valueOf(Natural.valueOf(&quot;1&quot;));
	
	// If the target is Integer it&#39;s equivalent to having BigInt as target 
	var Integer all = 1;  // equivalent to BigInt.valueOf(Natural.valueOf(&quot;1&quot;));
	
	// sufixes can be used to inform the compiler the corret type of the literal
	// for whole numbers only uppercase prefixes are allowed 
	var Int32 ii = 1T;  // equivalent to Int32.valueOf(&quot;1&quot;);
	var Int16 ss = 1S;  // equivalent to Int16.valueOf(&quot;1&quot;);
	var Int64 kk = 1L;  // equivalent to Int64.valueOf(&quot;1&quot;);
	var BigInt gg = 1G;  // equivalent to BigInt.valueOf(&quot;1&quot;);
	
	// Rationals are defined by the division of two whole positive values. 
	var Rational r = 2/3; // equivalent to Natural.valueOf(&quot;2&quot;).divide(Natural.valueOf(&quot;3&quot;))
	var Rational q = -5/8; // equivalent to Natural.valueOf(&quot;5&quot;).negate().divide(Natural.valueOf(&quot;8&quot;));
	var Rational q = -x/y; // equivalent to Natural.valueOf(x).negate().divide(Natural.valueOf(y));
	
	// In this case 1 is a Natural being promoted to a Decimal32.
	var Decimal32 f = 1; // equivalent to Decimal32.valueOf(Natural.valueOf(&quot;1&quot;));
	
	// decimal values are always assumed to be BigDecimals
	var Decimal32 ff = 1.6; // equivalent to Decimal32.valueOf(BigDecimal.valueOf(&quot;1.6&quot;));
	var Decimal64 d = 2.0; // equivalent to Decimal64.valueOf(BigDecimal.valueOf(&quot;2.0&quot;));
	var BigDecimal m = 1.234567890E100; // equivalent to BigDecimal.valueOf(&quot;1.234567890E100&quot;);

	// prefixes can also be used to informe the compiler the corret type of the literal
	// for non whole numbers only lowercase prefixes are allowed 
	var Decimal32 fff = 1.6f; // equivalent to Decimal32.valueOf(&quot;1.6&quot;);
	var Decimal64 dd = 2.0d; // equivalent to Decimal64.valueOf(&quot;2.0&quot;);
	var BigDecimal mm = 1m; // equivalent to BigDecimal.valueOf(&quot;1&quot;);
	
	
	var Imaginary a = 2i; // equivalent to Imaginary.valueOf(Natural.valueOf(&quot;2&quot;));
	var Imaginary b = 2.5i; // equivalent to Imaginary.valueOf(BigDecimal.valueOf(&quot;2.5&quot;));
	
	var Imaginary error = 2; // does not compile because natural ca 

	var Complex = 5 + 2i; // equivalent to Natural.valueOf(&quot;5&quot;).plus(Imaginary.valueOf(Natural.valueOf(&quot;2&quot;)))
	var Complex = 3.9 + 0.2i; // equivalent to BigDecimal.valueOf(&quot;3.9&quot;).plus(Imaginary.valueOf(BigDecimal.valueOf(&quot;0.2&quot;))
</code></pre><p>In any representation you can use _ to logically separate digits in the value to help readability.</p>
<pre><code class="brush: lense">	var Integer = -1_000_000;
</code></pre><h3>Literals Representations</h3><p>Numeral literals are assumed to be represented in decimal form (base 10) for all types.<br/>For naturals is possible to use the hexadecimal (base 16) form.</p>
<pre><code class="brush: lense">	var Natural color = #A3C1_F100; // hexadecimal
</code></pre><p>Some <code>Integer</code> implementations like Int32 and Int64 implement <code>Binary</code>. This means this numbers </p><p>Remeber whole literals are always assumed to be Natural values in decimal representation and promoted to other types when necessary.</p><h2>Byte and Binary</h2><p>Lense includes the <code>Binary</code> imutable interface to represent any value can be understanded as a sequence of bits. Each bit is represented as a Boolean value.</p><p><code>Byte</code> is a special class that implements <code>Binary</code> corresponding to a sequence of 8 bits. <code>Byte</code> is not a number and does not have an assigned numeric value. Also it as no arithemetic operations. It's primarily used for I/O operations.</p><p><code>Int16</code> , <code>Int32</code> and <code>Int64</code> also implement <code>Binary</code> corresponding to a sequence of 16, 32 and 64 bits respectivly. Because this values have a signed<br/>numeric value one of the bits (the left most bit) is reserved to determine the sign. The rest of the bits represent the value if the value is possitive (left most bit is zero), else represent the Two Complement representation of the value.</p><p><code>BitArray</code> is a mutable implementation of a <code>Binary</code> with variable bit size. </p><p>Lense offers a literal representation for <code>Binary</code>. Like in the decimal and hexadecimal representations we can use _ to separate digits.<br/>All binary literals are assumed to be <code>BitArray</code>s of the given number of bits. It is not possible to have zero bits. </p>
<pre><code class="brush: lense">	var Byte byte = $1111_0000; // equivalent to Byte.valueOf(BitArray.valueOf(1,1,1,1,0,0,0,0));
	var Int16 short = $1111_0000_1111_0000; // equivalent to Byte.valueOf(BitArray.valueOf(1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0));
	var BitArray flags = $1111_0000_0101_0110_0010_0001_0101_1001; // equivalent to BitArray.valueOf(1,1,1,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,1,0,1,0,1,1,0,0,1);
</code></pre><p>A <code>Byte</code> can be transformed explictitly to a <code>Natural</code> between 0 and 255 or to a Integer between -128 and 127.<br/>There is not automatic promotion from <code>Byte</code> to any type of <code>Number</code>.</p>
<pre><code class="brush: lense">	var Byte byte = $1111_0000; 
	var Natural n = byte.ToNatural(); // equivalent to 240;
	var Integer i = byte.ToInteger(); // -16
	
	var Natural error = byte; // illegal. Byte is not assignable to Natural.
</code></pre><h1>Object Orientation</h1><h2>Classes</h2><p>A class represents a structural template of an object and acts like a factory and protype ate the same time.<br/>You can define a class with the <code>class</code> keyword. Classes can named or anonymous.</p>
<pre><code class="brush: lense">/**A polar coordinate**/
public class Polar {

	private val Float angle; // imutable values
	private val Float radius; // imutable values
	
	// an initializer , aka constructor
	public Polar (Float angle, Float radius){
		this.angle = angle;
		this.radius = radius;
	}
	
	// some operations
    public Polar rotate(Float rotation) {
        return new Polar(this.angle+rotation, this.radius);
    }

    public  Polar scale(Float scale) { 
       return new Polar(angle, radius*scale);
	}

    public String toString () {
    	return &quot;({{radius}},{{angle}})&quot;;
    } 

}
</code></pre><p>The values angle and radius are imutable, so the class as a whole is imutable. When enforce this fact adding <code>val</code> to the class definition</p>
<pre><code class="brush: lense">/**An imutable polar coordinate**/
public val class Polar {

 ...
}
</code></pre><p>This will inform the compiler the values in the class are not ment to change and any tentative to do so will rise a compiler error.<br/>If all constructor parameters are intented to be imutable and private a simpler syntax can be used</p>
<pre><code class="brush: lense">/**An imutable, simplified, polar coordinate**/
public class Polar (Float angle, Float radius) {

	// the constructor is removed
	
	// some operations
    public Polar rotate(Float rotation) {
        return new Polar(this.angle+rotation, this.radius);
    }

    public  Polar scale(Float scale) { 
       return new Polar(angle, radius*scale);
	}

    public String toString () {
    	return &quot;({{radius}},{{angle}})&quot;;
    } 

}
</code></pre><p>A very common use of a class is to model Property Bag objects. Property Bags are intrisicly mutable objets and so is necessary something complitly diferent </p>
<pre><code class="brush: lense">/**An Addres as an example of a propertybag**/
public class Address  {

	public var String street;
	public var String number;
	public var String city;
	public var String zipcode;
	
}
</code></pre><p>Bacause those are public properties we can assign values to them, an read those values back, but because variables need to be inicialized before used<br/>and all properties are of type <code>String</code> that inicialization cannot be absent. So that code will not compile. We need to write it like this:</p>
<pre><code class="brush: lense">/**An Addres as an example of a propertybag**/
public class Address  {

	public var String? street;
	public var String? number;
	public var String? city;
	public var String? zipcode;
	
}
</code></pre><p>In the case the value can be absent the compiler will inicialize it like this , automaticly:</p>
<pre><code class="brush: lense">/**An Addres as an example of a propertybag**/
public class Address  {

	public var String? street = null;
	public var String? number= null;
	public var String? city= null;
	public var String? zipcode= null;
	
}
</code></pre><p>Remember <code>null</code> is a reserved word that represent <code>None.none</code>.</p></p>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">Lense is an open source project and a comunity diven developement</p>
      </div>
    </div>
    
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
    <script>
    	SyntaxHighlighter.config.tagName = 'code';
		SyntaxHighlighter.all();
    
    </script>
  </body>
</html>