<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Constructors</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">
    
    
  
	<script src="js/shCore.js"></script>

	<script src="js/shBrushScala.js"></script>
	<script src="js/shBrushCSharp.js"></script>
	<script src="js/shBrushDart.js"></script>
	<script src="js/shBrushJava.js"></script>
		
	<script src="js/shBrushLense.js"></script>
	<style>
	 .console {
	    background : black;
	    color: white;
	    width: 500px;
	 }
	 p {
	 	text-align:justified;
	 }
	 pre {
	 	background-color:white !important;
	 	border:0px !important;
	 	padding:0px !important;
	 	overflow: visible !important;
	 }
	 pre code {
	 	padding:2px !important;
	 	margin : 0px !important;
	 }
	</style>

    <!-- Le styles -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/asciidoctor.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">
  	<link rel="stylesheet" type="text/css" href="css/shCore.css"  >
	<link rel="stylesheet" type="text/css" href="css/shThemeLense.css" >
	
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">Lense</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="news.html">News</a></li>
            <li><a href="download.html">Download</a></li>
            <li><a href="documents.html">Documentation</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Development<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="https://github.com/sergiotaborda/lense-lang">Source Code</a></li>
                <!--
                <li><a href="#">Another action</a></li>
                <li><a href="#">Something else here</a></li>
                <li class="divider"></li>
                <li class="dropdown-header">Nav header</li>
                <li><a href="#">Separated link</a></li>
                <li><a href="#">One more separated link</a></li>
                -->
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
	<p><h1>Constructors</h1><p>In an Object Oriented language there is the innate need to instantiate objects. The instantiation occurs in two phases. First the memory needed to hold the object information is allocated and pointed at by a reference. Then this memory space is filled with initialization information. Only after these two phases are complete the object really exists and can be used by other objects.</p><p>The allocation phase can be manual like in C , Python and Swift or automatic like in C# or Java. Lense opts for an automatic allocation.</p><p>The initialization part is more delicate because the object must always exist in a valid state.<br/>For simple objects whose state is simply a bunch of properties that are initialized with default values, this process is straightforward. However when calculations or other computations are needed this presents a problem.</p><p>So there needs to be a contract between the machinery responsible for allocating and initializing the object and the object class. Some functions must be runned by this machinery in order to guarantee the object is in a valid state before it can be release in the wild.</p><p>This special function invoked by the machinery is called <em>Constructor</em>. Thus, the constructor is often an initialization method and it does not really constructs the object. Because the object already exists when the constructor is called (created in the previous phase of the instantiation process) the constructor has access to it to ensure the properties in the object are correctly set to valid values, however it should not call any polymorphic methods on the object.</p><p>As an example, in Java, we would write something like:</p>
<pre><code class="brush: java">public class Fraction {

	private int numerator;
	private int denominator;
	
	public Fraction (int numerator, int denominator){
		if (denominator == 0){
			trows new IllegalArgumentException(&quot;Denominator cannot be zero&quot;);
		}
		this.numerator = numerator;
		this.denominator = denominator;
	}
}

// and can be used like 

Fraction third = new Fraction(1,3);

</code></pre><p>Pay attention the constructor is vary similar to a method but as no return type and its name is the same as the class.</p><p>Inside the constructor, the <code>this</code> keyword refers to the already allocated object. So, at this point, the object already exists and it is of the class <code>Fraction</code>.The constructor has no means to return an object of another class because the constructor has no return.</p><p>The constructor , being a special kind of method can throw exceptions , however it is considered bad practice to do so[needs references].</p><p>Constructors are usefully to guarantee the object state is correctly initialized but have some limitations, so in practice you would prefer to use a static factory method , like so:</p>
<pre><code class="brush: java">public class Fraction {

	private int numerator;
	private int denominator;
	
	public static Fraction of(int numerator, int denominator){
		if (denominator == 0){
			throws new IllegalArgumentException(&quot;Denominator cannot be zero&quot;);
		}
		return new Fraction(numerator, denominator);
	}
	
	private Fraction (int numerator, int denominator){
		this.numerator = numerator;
		this.denominator = denominator;
	}
}

// but now the object is created like 

Fraction third = Fraction.of(1,3);
</code></pre><p>The validation of parameters is now moved to a method, so exceptions are allowed. The constructor is private so only the class can invoke it, the rest of the world would have to call the <code>of</code> static method.</p><p>The problem with static methods is that they are not inherited so, the static factory method pattern makes sense only for object not intended to be inherited from.<br/>Nevertheless considered a good practice e several API nowadays use this technique to hide the constructor and provide a more fluent instantiation. </p><p>A great think about this pattern is that it encasuplates the use of <code>new</code> so the class designed can change the parameters of the constructor at will without interfering with the call site.</p><p>People often criticize java for being to verbose. The numerator and denominator names appear 6 times.</p><h2>Types of constructors</h2><p>Other languages come up with new flavors of constructors to try to reduce the problems with constructors. However, because constructors are essentially linked with the concept of object instantiation and state validity they cannot be removed from the languages. Some type of constructor must exist.</p><h3>Primary Constructor</h3><p>This is special kind of constructors that only initializes properties in the object. It is functionally equivalent to the private constructor in our second example above. Because it can only set properties, languages try to come up with special (shorter) syntax.</p><p>In Scala, Ceylon and Kotlin, for instance, the primary constructor parameters are declared immediately after the class name and extra code can be added in the class body without any other special delimiters:</p>
<pre><code class="brush: scala"><br/>public class Fraction (Integer numerator, Integer denominator) {
    // other code goes where
}

</code></pre><p>This constructors immediately inform the compiler there must be a <em>numerator</em> and a <em>denominator</em> field in the class and the values of the parameters should be directly assign to those fields. This really reduces the boilerplate but leaves the validation of state problem orphan. </p><p>Scala resolves this by means of companion objects that have methods that act like a static factory methods calling the constructor only after validating the parameters are correct. Other special constructors are possible (called auxiliary constructors) but they action is limited. In scala constructors are pretty much meant only for field initialization, other computations are made in methods on objects.</p><p>In languages with primary constructors implemented like this trade one boilerplate for asymmetry: instead of having a delimited boilerplate inside a method like syntax, they provide a shorter syntax for the primary constructor making the other constructors syntax <em>ad hoc</em> and not symmetric, even to allow code in the class body and require the programmer to conform to special rules for execution of code inside the class body and inside the auxiliary constructors. They remove the boilerplate of having a constructors that sets the fields but have no dedicated place for "advanced" construction code and the class structure. If simple property bags in what you need this strategy really pays off, but it shows some cracks for more complex types that need to isolate construction a little better.</p><p>Dart goes another way.</p>
<pre><code class="brush : dart">class Fraction  {
	Integer numerator;
	Integer denominator;

   Fraction (this.numerator, this.denominator)
}

</code></pre><p>The syntax is different, more in line with the C syntax like Java, but the intent is the same: reducing boilerplate, but maintaining the tradiconal way constructors are represented.<br/>However we are obliged to repeat the class name simply by the convention rule constructors are created this way.<br/>Traditionally the C family languages do not use a keyword for the constructor because it was introduces in the language after de initial design and so create a keyword could conflict with existing names in existing code. So the designed made it so the code for the construtor was not valid code in the previous versions.Them, by historic and similarity reason more modern languages simply copied the syntax like Java and Dart.<br/>The "same name" rule is not always the case. Scala uses <code>def this()</code> and some languages use <code>new</code> in an attempt to not introduce a dedicated keyword. </p><p>In Lense the primary constructor is written :</p>
<pre><code class="brush: lense "><br/>public class Fraction {

   val Integer numerator;
   val Integer denominator;
   
   constructor (Integer numerator, Integer denominator);
}

// invoke like 

val Fraction third = new Fraction(1, 3);
</code></pre><p>A constructor without a body means the parameters should be copied to the fields.</p><p>All final value fields (the ones with <code>val</code>) must be initialized by all constructors, i.e. the compiler must be able to prove that all <code>val</code> fields have been set by the constructor. If this is not the case a compilation error will be raised.</p><p>There is no repetition of the class name and the keyword clearly states that the instruction is a constructor.<br/>There is no boilerplate. The types on the parameters are needed since the private fields must not have the same types.</p><h2>Named Constructors</h2><p>All is fine when the class only needs a constructor. But more time than people would realize an object can be created by different forms. Design can argument this other forms should be handled by factory object and the class it self as only a set of parameters. While this can obviously accomplished is not practical. </p><p>If we intend to have a <code>Color</code> type that can be created from RGB or HSL values the two algorithms are different and one or both require calculations before we can set the object private fields. On the other hand we need some practical way of distinguishing between them. Here the static method factory come in handy because it provides a name to the construction form. So in java we could write</p>
<pre><code class="brush: java ">Color a = Color.fromRGB(1.0 , 1.0 , 1.0);
Color b = Color.fromHSL(60 , 0.5 , 0.5); 
</code></pre><p>However there is no <code>new</code> keyword being used. Dart provides the same sintax but using <code>new</code>:</p>
<pre><code class="brush: dart ">Color a = new Color.fromRGB(1.0 , 1.0 , 1.0);
Color b = new Color.fromHSL(60 , 0.5 , 0.5); 
</code></pre><p>In Dart you can provide named constructors like</p>
<pre><code class="brush: dart "> class Color {

    Color.fromRGB(red, greee, blue){
         // code goes here  
    }
    
    Color.fromHSL(hue, saturation, lightness){
         // code goes here  
    }

}
</code></pre><p>Its a little odd to have dots in the name of the constructor , but at least is consistent with the tradiconal constructor syntax. In Lense because we have the <code>constructor</code> key word we simply write the same as:</p>
<pre><code class="brush: lense ">class Color {

    constructor fromRGB(Rational red, Rational greee,Rational blue){
         // code goes here  
    }
    
    constructor fromHSL(Angle hue,Rational saturation,Rational lightness){
         // code goes here  
    }

}
</code></pre><p>and invoke them in the same way </p>
<pre><code class="brush: lense ">Color a = new Color.fromRGB(1.0 , 1.0 , 1.0);
Color b = new Color.fromHSL(60 , 0.5 , 0.5); 
</code></pre><p>Note the similarity with the anonymous constructor invocation.</p><p>The named constructors must, at some point, directly or indirectly, invoke the primary constructor. So the final code should be something like</p>
<pre><code class="brush: lense ">public class Color {

	 val Natural rgb;
	 
	private constructor(Natural rgb);
	
    public constructor fromRGB(Rational red, Rational greee,Rational blue){
         	Natural rgb = red * 255;
			rgb = (rgb &lt;&lt; 8) + green * 255;
			rgb = (rgb &lt;&lt; 8) + blue * 255;
			return new Color(rgb);
    }
    
    public constructor fromHSL(Angle hue,Rational saturation,Rational lightness){
         // code goes here to caculate red, green and blue from the parameters , then call the fromRGB constructor
         Rational red = ...
         Rational green = ...
         Rational blue = ...
         return new Color.fromRGB(reg,green,blue);
    }

}
</code></pre><p>Notice how the <code>new</code> keyword is used to call the other constructors. In fact constructors in Lense act as factories and can return any object that could be assigned to the class.</p><h2>Factory Constructor</h2><p>Constructors in Lense are real factories and can create and return any instance. This means constructors can control the number of instances being created and choose to create specific sub types. For instances the <code>Array</code> constructor is :</p>
<pre><code class="brush: lense ">public class Array&lt;T&gt; {

        constructor (Natural size){
        	if (T is Int32){
        	    return new Int32Array(size);
        	} else if (T is Int64){
        	    return new Int64Array(size);
        	} else if (T is Byte){
        	    return new ByteArray(size);
        	} else {
        	    return new ObjectArray&lt;T&gt;(size);
        	}
        }
}
</code></pre><p>The <code>Natural</code> constructor is equivalent to:</p>
<pre><code class="brush: lense ">public class Natural extends Whole {

	object cache {
		val values = new Array&lt;Natural&gt;();
	}

    constructor (Natural other){
       	if (other &gt;= -2 &amp;&amp; other &lt; 100){
       		val cached = cache.values[other].or(other); 
       		cache[cached] = cached;
       		return cached;
       	}
       	return other;
    }
    
    constructor parse (String value){
    	if (value.startsWith(&quot;-&quot;)){
    		throw new ParseException(&quot;Value cannot be negative&quot;);
    	}
    	if (value.contains(&quot;.&quot;)){
    		throw new ParseException(&quot;Value cannot be decimal&quot;);
    	}
    	
    	Natural power = 0;
    	Natural value = 0;
    	for(char in value.replaceAll(&quot;_&quot;,&quot;&quot;){
    	
    		val digit = char.toDigit();
    		
    		if (digit == none){
    			throw new ParseException(char + &quot;is not a digit.&quot;);
    		}
    		value += digit * 10**power;
    		
    		power++;
    	}
    	
    	return new Natural(value);
    }
}

</code></pre><p>It uses and <a href="objects.html"><code>object</code></a> to hold the cache data. If the String is not valid the constructor throws an exception.<br/>This is valid because a constructors is like a factory, however the compiler will only allow the <code>throw</code> clause on a named constructor.</p><h2>Conversion Constructor</h2><p>A conversion constructor is used to obtain the state of the object from another object of a different type. For instance:</p>
<pre><code class="brush: lense ">Integer k = 23;
</code></pre><p>Because all whole literals are understanded by the compiler as <code>Natural</code>s, 23 is really a <code>Natural</code>. On the other hand, because <code>Natural</code>s are not <code>Integer</code>s the assignment would not be valid. Before a compilation error is risen, the compiler tries to find an anonymous constructor in the class Integer that is marked as <code>implicit</code> and has a single parameter of type <code>Natural</code>. </p>
<pre><code class="brush: lense "><br/>public class Integer extends Whole {

	implicit constructor Integer(Natural other){
		return new Integer(other.toString()); // this is not the real code, just and example.
	}
}

</code></pre><p>If it exists, the compiler changes the assignment to:</p>
<pre><code class="brush: lense ">Integer k = new Integer(23);
</code></pre><p>The <code>implicit</code> keyword is necessary because not every anonymous constructor with a single parameter is meant to be a conversion constructor. The <code>Array&lt;T&gt;</code> class (used above) has a constructor that receives a <code>Natural</code> to set the array size,but that without the implicit keyword would mean that:</p>
<pre><code class="brush: lense ">Array&lt;Integer&gt; array = 3;
</code></pre><p>was really </p>
<pre><code class="brush: lense ">Array&lt;Integer&gt; array = new Array&lt;Integer&gt;(3);
</code></pre><p>The instruction would be trying to assign the number 3 to an array but the compiler would try to promote the value.<br/>This would not be a very coherent form to create arrays because can be confused with:</p>
<pre><code class="brush: lense ">Array&lt;Integer&gt; array = [3];
</code></pre><p>The programmer may have forgotten to surround the value to be put in the array with brackets. </p><p>Also, this other example could be made to be valid code using a conversion constructor:</p>
<pre><code class="brush: lense ">Uri address = &quot;http://www.google.com&quot;
</code></pre><p>But this form is not recomemded because an implicit constructor, as primary constructors, can not throw exceptions.<br/>So a parse operation, that possibly could go wrong, is not suited to a conversion constructor. It is recomemded that a constructor based on a string be a named constructor like <code>parse(String)</code>. Named constructors can throw exceptions.</p><p>As we can see from the above examples, that the conversion constructor is a simple way to promote values of one class to another but only if it is guaranteed that conversion will never fail.</p><p>As a limitation of conversion constructors the process only works if the class on the left side of the assignment accepts the instances of the class on the right side as valid argument. </p><h2>Constructors Enhancement</h2><p>If the original designer of the left side class did not added the conversion constructor for some other class we can add one latter by creating an <a href="enhancements.html">enhancement</a>, like so:</p>
<pre><code class="brush: lense ">public enhancement AddNaturalConvertionConstrutorToString extends String { // enhances String

	public implicit constructor (Natural n){
	       return n.toString();
	}
}
</code></pre><p>With this enchamenent in scope we can write:</p>
<pre><code class="brush: lense ">String s = 8; // not supported without the enhancement
</code></pre><p>This is very powerful feature of <a href="enhancements.html">enhancements</a> and can easly be abused, so please design enhancements with care. </p></p>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">Lense is an open source project and a comunity diven developement</p>
      </div>
    </div>
    
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
    <script>
    	SyntaxHighlighter.config.tagName = 'code';
		SyntaxHighlighter.all();
    
    </script>
  </body>
</html>