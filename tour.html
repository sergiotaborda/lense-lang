<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Tour</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">
    
    
  
	<script src="js/shCore.js"></script>

	<script src="js/shBrushScala.js"></script>
	<script src="js/shBrushCSharp.js"></script>
	<script src="js/shBrushDart.js"></script>
	<script src="js/shBrushJava.js"></script>
		
	<script src="js/shBrushLense.js"></script>
	<style>
	 .console {
	    background : black;
	    color: white;
	    width: 500px;
	 }
	 p {
	 	text-align:justified;
	 }
	 pre {
	 	background-color:white !important;
	 	border:0px !important;
	 	padding:0px !important;
	 	overflow: visible !important;
	 }
	 pre code {
	 	padding:2px !important;
	 	margin : 0px !important;
	 }
	</style>

    <!-- Le styles -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/asciidoctor.css" rel="stylesheet">
    <link href="css/base.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">
  	<link rel="stylesheet" type="text/css" href="css/shCore.css"  >
	<link rel="stylesheet" type="text/css" href="css/shThemeLense.css" >
	
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->

    <link rel="shortcut icon" href="icon.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">Lense</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Get Started<b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li class="disabled"><a href="learn.html">Learn Lense</a></li>
					<li class="disabled"><a href="try.html">Try Lense</a></li>
					<li><a href="https://github.com/sergiotaborda/lense-lang">Download</a></li>
				</ul>
			</li>
            <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Fundamentals<b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="tour.html">Language Tour</a></li>
					<li class="disabled"><a href="guide.html">Programmer's Guide</a></li>
					<li><a href="platforms.html">Target Platforms's Guide</a></li>
				</ul>
            </li>
			
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Details<b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="numbers.html">Numbers</a></li>
					<li><a href="strings.html">Strings</a></li>
					<li><a href="objects.html">Classes and Objects</a></li>
					<li><a href="constructors.html">Constructors</a></li>
					<li><a href="operators.html">Operators</a></li>
					<li><a href="containerLiterals.html">Container Literals</a></li>
					<li><a href="sumtypes.html">Sum Types</a></li>
					<li><a href="monads.html">Monads</a></li>
					
					<li class="disabled"><a href="enhancements.html">External Enhancements</a></li>
					<li class="disabled"><a href="concurrency.html">Concurrency</a></li>
				</ul>
            </li>
			<li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">More<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="https://github.com/sergiotaborda/lense-lang">Source Code</a></li>
			    <li><a href="https://groups.google.com/forum/#!forum/lense-lang">Discussion Group</a></li>
				
				<li><a href="status.html">Roadmap &amp; Status</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
	<div class="corner-ribbon top-right sticky shadow"><a href="status.html">Exploration Stage</a></div>
    <div class="container">
	<p><p>This a simple tour of the language. At this stage some feature are no decided upon, so sintax may change and features may be added or removed.<br/>Features that may change are marked as <em>Under Consideration</em>.</p><h1>A basic Lense program (Under consideration)</h1>
<pre><code class="brush: lense ">module application (1.0.0) {

	public Void run (){
		Console.println(&quot;Hello, world!&quot;);
	}
}
</code></pre><p>Lense supports modules, and there must always exist a module in you application (you application <em>is</em> a module).<br/>A module can be executable if it implements the <code>run</code> function. </p><p>Each module must have a name and a version. In this case the name is "application" and the version is 1.0.0.<br/>If you need to access to passed arguments (like in a command line application) you can read them from <code>Runtime.Arguments</code>. This is a read only <code>Sequence&lt;String&gt;</code> containing the passed arguments.<br/>If no arguments were passed or the application is running in an environment without access to arguments (like a web browser) the sequence is empty.</p><h1>Important concepts</h1><p>Lense is base in some concepts that are always present.</p>
<ul>
  <li><p>Lense aims to be a universal language in the sense it can be executed on several target platforms. For these reason some features are only available for some platforms. For example, file system is not available for the JavaScript platform targeting browsers, since browser have no native access to file systems. On the other hand only a web application targeting JavaScript on a browser can call a DOM API and receive events and such.<br/>For more on target platforms read the <a href="platforms.html">plataforms guide</a></p></li>
  <li><p>Everything you can place in a variable is an object, and every object is an instance of a class.<br/>Even numbers and functions are objects. All classes inherit from the <code>Any</code> class. </p></li>
  <li><p>Modules, and not classes, are the units of deployment. All code compiled in Lense will produce a Module.<br/>Modules can be organized in packages. Classes live in packages. Module are compiled depending on the target platform. The same module source code can produce several module archives, one for deployment in each platform. (Under revision)</p></li>
  <li><p>Lense is strong typed and supports type inference. Specifying types in code allows the compiler, and other tools, to reason about your intent and is required at definition sites like classes, interfaces and methods but is optional at call site every-when the compiler could infer the type.</p></li>
  <li><p>There is no explicit static scope. Hence, there is no <code>static</code> keyword. All members are objects that belong to objects. However, the <code>object</code> declaration allows to the definition of singleton objects that exist in a <em>static-like</em> context. You refer to these objects by their names as the name are unique. </p></li>
  <li><p>Identifiers can start with a letter, followed by any combination of characters and digits.</p></li>
</ul><h1>Reserved words and keywords</h1><p>Lense, like all languages, reserves some words that cannot be used as identifiers.<br/>Some of these reserved works are keywords, e.i. they have special meaning to the compiler.</p>
<table>
	<tr>
		<td>abstract</td>
		<td>as</td>
		<td>break</td>
		<td>case</td>
		<td>catch</td>
	</tr>
	<tr>
		<td>class</td>
		<td>continue</td>
		<td>default</td>
		<td>do</td>
		<td>else</td>
	</tr>
	<tr>
		<td>export</td>
		<td>extends</td>
		<td>finally</td>
		<td>for</td>
		<td>if</td>
	</tr>
	<tr>
		<td>import</td>
		<td>in</td>
		<td>inv</td>
		<td>module</td>
		<td>new</td>
	</tr>
	<tr>
		<td>null</td>
		<td>out</td>
		<td>package</td>
		<td>return</td>
		<td>super</td>
	</tr>
	<tr>
		<td>switch</td>
		<td>this</td>
		<td>throw</td>
		<td>try</td>
		<td>val</td>
	</tr>
	<tr>
		<td>var</td>
		<td>while</td>
		<td>true</td>
		<td>false</td>
		<td></td>
	</tr>
</table><h1>Variables and Values</h1><p>Creating variables in Lense is very similar to other languages.</p>
<pre><code class="brush: lense">var String name = &quot;Alice&quot;;
</code></pre><p>Variables always contain references to objects. The variable called <em>name</em> contains a reference to a <code>String</code> object with a value of "Alice".<br/>The reference contained in a variable can be changed further down the code to another reference, like :</p>
<pre><code class="brush: lense">var name = &quot;Alice&quot;;
name = &quot;Beth&quot;;
</code></pre><p>Lense prefers immutable references, so if you do not use the <code>var</code> keyword, Lense will assume the <code>val</code> keyword.</p>
<pre><code class="brush: lense">val String name = &quot;Alice&quot;;
</code></pre><p>or </p>
<pre><code class="brush: lense">String name = &quot;Alice&quot;; // val is implicit.
</code></pre><p>Immutable values cannot be changed, so trying to do so is a compilation error.</p>
<pre><code class="brush: lense">val String name = &quot;Alice&quot;;
name = &quot;Beth&quot;; // Compilation Error 
</code></pre><h2>Nullability</h2><p>Variables (immutable or not) must be initialized with values. Lense does not allow uninitialized variables to be used. So, this code will fail:</p>
<pre><code class="brush: lense">String name;

Console.println(name); // Compilation error. Variable was not initialized.
</code></pre><p>In addition, Lense as no concept of "null reference". References always exist.<br/>This will also fail:</p>
<pre><code class="brush: lense">String name = null; // Compilation error. Lense does not recognize the null keyword (even though is a reserved word)

Console.println(name); 
</code></pre><p>However, Lense understands possible absent values if you use a <code>Maybe&lt;T&gt;</code> type. The <code>Maybe&lt;T&gt;</code> type is a <a href="monads.html">monad type</a>.</p>
<pre><code class="brush: lense">val String? name;   

Console.println(name); // prints &quot;null&quot;;

name = &quot;Alice&quot;;

Console.println(name); // prints &quot;Alice&quot;;
</code></pre><p>The ? sign after the <code>String?</code> type is a shorthand notation for <code>Maybe&lt;String&gt;</code>. </p><h1>Built-in types</h1><p>The Lense language has special support for the following types:</p>
<ul>
  <li>Number</li>
  <li>Binary</li>
  <li>String</li>
  <li>Boolean</li>
  <li>Progression</li>
  <li>Interval</li>
  <li>Sequence (like Arrays and Lists)</li>
  <li>Assignment (like Maps)</li>
  <li>Tuple</li>
</ul><p>You can initialize an object of any of these special types using a <a href="containerLiterals.html">literal</a>. For example, 'this is a string' is a string literal, and <code>true</code> is a boolean literal.</p><p>Because every variable in Lense refers to an object, that is an instance of a class, you can usually also use constructors to initialize variables.<br/>Some of the built-in types have their own constructors. For example, you can use the <em>Map()</em> constructor to create a map, using code such as <code>new Map()</code>.</p><h2>Numbers</h2><p>Numbers are separated in specific algebraic structures that conform to the mathematical rules of the group of elements.<br/>All numbers are descendent types of the <code>Number</code> class. Operations are defined for each type independently.<br/>Lense supports Natural, Integer, Real, Complex and Imaginary numbers. A byte is not a number in Lense.</p><p>Natural is used as an indexer for sequences. It is non-negative and has big as you need. Limits for the size of collections like arrays, lists and maps are only bound by their implementation. Using a Natural to index sequences removes the necessity to check for negative indexes and as Arrays always have a upper limit and always are constructed by <a href="constructors.html">factory like constructors</a><br/>the implementation for each platform can accommodate different implementations according to maximum length demand.<br/>For more information on how <code>Natural</code> relates to index of sequences, see how <a href="arrays.html">Arrays</a> work in Lense.</p><p>Arithmetic operations are defined by <a href="operators.html">Operator Interfaces</a> so you can implement you own versions of the common operators.</p><p>For more detail on number visit the dedicated <a href="numbers.html">numbers</a> page</p><h2>Strings</h2><p>A string in Lense is a Sequence of Character. Characters are UTF-16 code points. A string literal is just a text enclosed in double quotes.</p>
<pre><code class="brush: lense">val String greating = &quot;Hello, world&quot;;
</code></pre><p>You can interpolate values inside literal strings using <code>{{</code> and <code>}}</code> as delimiters.</p>
<pre><code class="brush: lense">val String name = &quot;Alice&quot;;
val String greating = &quot;Hello, {{ name }}&quot;;
</code></pre><p>You can concatenate strings using the <code>+</code> operator.</p>
<pre><code class="brush: lense">val String name = &quot;Alice&quot;;
val String greating = &quot;Hello, &quot; + name;
</code></pre><p>String are mulit-line, so you can simply right</p>
<pre><code class="brush: lense">val String greating = &quot;Hello, 
	wold&quot;;
</code></pre><p>The line break , tab and spaces in the second line will be preserved.</p><p>If you need to use a Unicode a special character enclosing an hexadecimal natural value with <code>\{</code> and <code>}</code> delimiters.</p>
<pre><code class="brush: lense">val String define pi = &quot;The value of \{#03C0} is the ratio between the circumference and the diameter of a circle&quot;
</code></pre><h2>Booleans</h2><p>To represent boolean values, Lense has a type named <code>Boolean</code>. Only two objects have type Boolean: the boolean literals <code>true</code> and <code>false</code>, which are both compile-time constants.<br/>Lense is strong types and only allows Boolean values and expressions where a Boolean is expected. For example, the following code will not compile:</p>
<pre><code class="brush: lense">val String name = &quot;Alice&quot;;
if (name){  // Compilation error. Expected Boolean expression
	printName(name);
}
</code></pre><h1>Collections</h1><p>Lense offers a rich API to handle collections. All collections in Lense are <a href="monads.html">monads</a>.<br/>All collections inherit from the <code>Assortment</code> class and are read-only and immutable by design. Mutable implementations exist.</p><h2>Sequence</h2><p>Sequences are assortments that let you assign a <code>Natural</code> index to each element. The elements can be iterated in the order of their indexes.<br/>Sequences are immutable and read-only. Sequences are fundamental in Lense and not Arrays as in other languages (like Java).<br/>Lense provides a very familiar syntax for sequences:</p>
<pre><code class="brush: lense">val Sequence&lt;String&gt; cities = [&quot;New York&quot;, &quot;London&quot;, &quot;Paris&quot;];

val london = cities[1]; // access by a natural index
</code></pre><h3>Arrays</h3><p>In Lense arrays are editable sequences. This means you can chance the values in each position of the sequence but you cannot change the sequence's size.<br/>Arrays in Lense are fixed in size. To add a new element to the array you need to create a new array. Also keep in mind arrays in Lense are objects of the <code>Array&lt;T&gt;</code> class and not primitive types like in Java.</p>
<pre><code class="brush: lense">val Array&lt;String&gt; cities = [&quot;New York&quot;, &quot;London&quot;, &quot;Paris&quot;];

val london = cities[1]; // access by a natural index

cities[1] = &quot;São Paulo&quot;; // position 1 now refers to &quot;São Paulo&quot; and not to &quot;London&quot; any more.
</code></pre><p>Because of Lense's <a href="constructors.html">conversion constructors</a> you can initialize an Array with a Sequence literal.</p><h3>Lists</h3><p>Lists are Sequence that are both editable (like Arrays) and resizeable. This means you can add and remove elements from a list after the list is created.</p>
<pre><code class="brush: lense">val List&lt;String&gt; cities = [&quot;New York&quot;, &quot;London&quot;, &quot;Paris&quot;];

cities.remove(1); // removes element at index 1, &quot;London&quot; in this example
cities.add(&quot;São Paulo&quot;); // add a new element at end of the list
</code></pre><h3>Progression</h3><p>Lense supports Progressions. A Progression is a special sequence of elements that has a <em>start</em> and an <em>end</em> and know how to iterate elements from the start to the end.<br/>A Progression is normally created from a Progressable. A Progressable defines an <code>upTo</code> method that returns a progression.</p>
<pre><code class="brush: lense">val Progression&lt;Natural&gt; range = 1.upTo(9);
</code></pre><p>This constructs a progression from 1 inclusive to 9 inclusive. Lense also supports an operator called <code>..</code> that you can use instead of <code>upTo</code>.</p>
<pre><code class="brush: lense">val Progression&lt;Natural&gt; range = 1..9;
</code></pre><h2>Association</h2><p>Associations are like sequences, but instead of attributing an Natural index to each element, you can attribute an object to each element. Lense also provides a familiar literal for Associations.</p>
<pre><code class="brush: lense">val Association&lt;String, String&gt; personsAndJobs = { &quot;Alice&quot;: &quot;CEO&quot;, &quot;Bob&quot;:&quot;CIO&quot; , &quot;Claude&quot;:&quot;CFO&quot; };
</code></pre><p>Like Sequences, Associations are immutable and read-only.</p><h3>Maps</h3><p><code>Map&lt;K,V&gt;</code> is an implementation of <code>ResizableAssociation&lt;K,V&gt;</code> you can use to manipulate editable and resizeable associations. In Lense, Map is not an interface but an implementation (similar to an HashMap in Java)</p>
<pre><code class="brush: lense">val Map&lt;String, String&gt; personsAndJobs = { &quot;Alice&quot;: &quot;CEO&quot;, &quot;Bob&quot;:&quot;CIO&quot; , &quot;Claude&quot;:&quot;CFO&quot; };

personsAndJobs.removeKey(&quot;Alice&quot;); // removes the key and its value.
</code></pre><h2>Tuples</h2><p>Tuples are special collections. The are sequences of objects in the sense each element has an index. The difference is that each element can be of a different type with no relation to the other elements (has in a sequence all elements have to of the same class or inherit from it).</p>
<pre><code class="brush: lense">val (String, Natural , Boolean) personsAndJobs = (&quot;Alice&quot;, 42 , true);
</code></pre><p>Lense provides the abose short sintax to create tuple's types and values. the compiler will translate that notation to the following notation that you can also use.</p>
<pre><code class="brush: lense">val Tuple&lt;String, Tuple&lt;Natural , Tuple&lt;Boolean, Nothing&gt;&gt;&gt; personsAndJobs = (&quot;Alice&quot;, 42 , true);
</code></pre><p>If you are interested, you can read <a href="containerLiterals.html">more on container literals</a>. </p><h1>Functions</h1><p>Functions allow for algorithms to be encapsulated. Normally this algorithms depend on parameters that the function declares explicitly and return a value.</p>
<pre><code class="brush: lense">	 public Void doSomething() { 
	 	Console.print(&quot;Did something&quot;);
	 }
	 
	 Natural square (Natural x) { 
		return x*x; 
	 }
</code></pre><p>Functions always return a value. <code>Void</code> is not a keyword is an actual type. <code>Void</code> only has one instance denoted <code>()</code> (the empty tuple). All functions have an implicit return of the instance of <code>Void</code> at the end. This is correct unless the method return another type.<br/>You can explicitly write a return of the instance of <code>Void</code>.</p>
<pre><code class="brush: lense">	 public Void doSomething()  { 
	 	Console.print(&quot;Did something&quot;);
	 	return; // implicitly return the instance of Void.
	 };
</code></pre>
<pre><code class="brush: lense">	 public Void doSomething()  { 
	 	Console.print(&quot;Did something&quot;);
	 	return (); // explicit return the instance of Void.
	 };
</code></pre><p>Functions are objects named <em>Function</em>. Really is a type for each number of parameters. So <code>Function&lt;R&gt;</code> is for a function with no parameters that returns a type <code>R</code>. <code>Function&lt;R,T&gt;</code> if for a single parameter function.<br/><code>Function&lt;R,T,U&gt;</code> is for a function of two parameters, and do on ...</p>
<pre><code class="brush: lense">	 Function&lt;Int, Int&gt; f = x -&gt; x*x; 
	 Function&lt;Int, Int, Int&gt; g = (x,y) -&gt; x*y;
	 
	 Console.println(f(3));  
	 Console.println(g(3,2));
</code></pre><p>Prints</p>
<pre><code class="console">9					
6					
</code></pre><p>When functions are defined in the context of a class we talk about methods. Methods are functions bound to an instance of a class.<br/>Method can make calls to the <code>this</code> variable that implicitly represent the instance the function is bonded to.</p><h2>Transforming Methods into Functions (Under Consideration)</h2><p>Using reflection, methods can be converter to functions that can be invoked if the instance object is passed explicitly </p>
<pre><code class="brush: lense">	val Integer one = 1;

    val Integer minusOne = one.negative();

    // extract the underlying function
    val Function&lt;Number,Number&gt; negativeOf = one::negative(); // f has a parameter of type Number representing the bounded value of *negative*.

    val Integer alsoMinusOne = negativeOf(one);
	val Integer minusTwo = negativeOf(2);
</code></pre><p>Note the use of the <code>::</code> operator to detach members from object instances.<br/>You can do the same using the class instead of the instance</p>
<pre><code class="brush: lense">    // extract the underlying function
    val Function&lt;Number,Number&gt; negativeOf = Integer::negative(); // f has a parameter of type Number representing the bounded value of *negative*.

    val Integer alsoMinusOne = negativeOf(one);
	val Integer minusTwo = negativeOf(2);
</code></pre><h1>Operators</h1><p>Lense does not support operator overloading but lets you use operators like <code>+</code> and <code>*</code> in your own classes. Each operator is defined in a interface.<br/>For example , for the <code>+</code> operator is the <code>Summable&lt;A,D,S&gt;</code> interface. These special interfaces are called <em>Operator Interfaces</em> in the documentation.</p><p>Note that this interfaces do not define the result or the parameters must be of the same type. They as generic as you can get.</p><p>Another family of interfaces define algebraic structures. These structures enforce other rules (like the types all be the same) and provide properties for the underlying type.<br/>Algebraic structures help model some more abstract algebra concepts like <em>Magma</em>, <em>Group</em> , <em>Ring</em> or <em>Field</em>. </p><p>The different algebraic structures are the reason not all number types have the same operations. Integer, for example, do not have division, and so cannot for a <em>Field</em>.</p><h1>Control Flow Statements</h1><p>Lense control flow is pretty much what you would expect and are a costumed to see in other languages.</p><h2>if-then-else</h2><p>The <em>if-then-else</em> decision statement is pretty much the same as in Java , C# and other languages.</p>
<pre><code class="brush: lense">if (condition){
   // do somthing
} else if (otherCondition){
   // do this other thing
} else {
   // do something else.
}
</code></pre><p>The <code>if</code> clause demands a Boolean condition to be evaluated. The condition must be of type boolean. Any other type will throw a compilation error.<br/>You can chain and nest <em>if-then-else</em> as much as you like.</p><h2>while-do</h2><p>The <em>while-do</em> repetition structure is also pretty much the same as in Java , C# and other languages.</p>
<pre><code class="brush: lense">while (condition){
	// repeat this if condition is true
}
</code></pre><h2>for-each</h2><p>A very common task in object oriented programming is iterating over a collection of elements. Lense provides the <em>for-each</em> structure to help in this very common task.</p>
<pre><code class="brush: lense">for (var element in collection){
	// repeat this code for each element 
}
</code></pre><p>You can use <em>for-each</em> with any object that implements the <code>Iterable</code> interface.<br/>You can use type of the variable instead of var. If you use <code>var</code> the type will be infered from the collection signature.</p>
<pre><code class="brush: lense">for (String element in collection){
	// repeat this code for each element 
}
</code></pre><p>Lense does not have the traditional increment base <em>for</em> like it exist in Java or C#.</p>
<pre><code class="brush: java">for (int i = 1; i &lt;= 9  ; i++){  // this exists in Java and C#, not in Lense
	// repeat for each i
}
</code></pre><p>Instead you can use a Progression.</p>
<pre><code class="brush: lense">for (var i in 1..9){
	// repeat for each i
}
</code></pre><h1>Exceptions</h1><p>Lense supports throwing Exceptions. An Exception is a special object. When an Exception is thrown the execution of the code stops and the method returns.<br/>You can that catch the exception with a <em>try-catch-finally</em> statement.</p>
<pre><code class="brush: lense">try {
  // do something that can throw an exception
  throw new ArithmenticException();
} catch (ArithmenticException e) {
  // do something is the exception occurred
} finally {
  // do something either if the exception occurred or not.
}
</code></pre><p>Lense does not support checked exception like Java does. </p><h1>Classes</h1><p>Lense supports classes and class inheritance to define objects and relations betweeen them.<br/>Lense also supports interfaces, object delcarations and traits (under consideration).</p><p>All Lense types suport fields, properties , methods and constructors as members.<br/>Lense also supports overloading of methods and genric types.</p><p>More on types on the <a href="objects.html">types page</a>.</p><h1>Generics</h1><p>Lense supports reified generics with variance control. </p>
<pre><code class="brush: lense">public interface Sequence&lt;out T&gt; { }

public interface Validator&lt;in T&gt; { }

public interface List&lt;T&gt; { }
</code></pre><p>Lense support co-variant types (out), contra-variant types (in) and invariant types (default) </p><h1>Modules and visibility (Under Consideration)</h1><p>Lense supports modules. Every application or library is packaged as a module. A modulue is similar to a jar file in java or a dll in .Net,<br/>but contains a little more structure.</p><p>Modules can import types from other modules and can export they own types to other modules to use.</p><p>Visibility modifies like <code>private</code>, <code>public</code> and <code>protected</code> have the same semantics an in java or C#, however there is no <em>default</em> level like in java.<br/>If visibility is not explicit , <code>private</code> is used. </p><p>A litte diference is that a type being maked as <code>public</code> adicionaly means that any other module can used it and are exported by default. If you do not want to export a classe use the <code>internal</code> visibility modifier.</p><h1>Parallelism and Concurrency (Under Consideration)</h1><p>Lense does not support creating an control of threads directly nor support the commom memory model.<br/>Instead Lense provides an actor based API to handle concurrency and parallelism. Parallelism is also ofered by special APIs lik Parallelism is supported by APIs like <code>Iterable.asParallel()</code>. </p><h1>Reflection (Under Consideration)</h1><p>Lense offer a reflection API based on the <code>Type</code> class. </p>
<pre><code class="brush: lense">   val Type stringType = typeOf(String);
   val Type alsoStringType = &quot;some String&quot;.getType(); 

   Console.println(&quot;String as {{stringType.Methods.size}} methods&quot;);
</code></pre><h1>Comments</h1><p>Lense supports inline comments with <code>//</code> and multi-line comments with <code>/{</code> and <code>}/</code></p>
<pre><code class="brush: lense">/{
    this is a multi-line comment

     /{
       Multi-line comments can be nested
     }/
}/
public class Client {

     // the following line uses a single line comment to inform the role of the field
      val Natural name; // the name of the client       
}
</code></pre><p>As in other languages comments should be avoid by renaming your types and members with better names, but some times<br/>you will need them to explain some complex algorithm.</p></p>
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">Lense is an open source project and a community driven development</p>
      </div>
    </div>
    
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="js/jquery-1.11.1.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
    <script>
    	SyntaxHighlighter.config.tagName = 'code';
		SyntaxHighlighter.defaults.toolbar = false;
		SyntaxHighlighter.all();
    
    </script>
  </body>
</html>