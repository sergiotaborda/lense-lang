<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Tour</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">
    
    <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-77665803-1', 'auto');
	  ga('send', 'pageview');

	</script>
  
	<script src="../js/shCore.js"></script>

	<script src="../js/shBrushScala.js"></script>
	<script src="../js/shBrushCSharp.js"></script>
	<script src="../js/shBrushDart.js"></script>
	<script src="../js/shBrushJava.js"></script>
	<script src="../js/shBrushLense.js"></script>


    <!-- Le styles -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">
  	<link rel="stylesheet" type="text/css" href="../css/shCore.css"  >
	<link rel="stylesheet" type="text/css" href="../css/shThemeLense.css" >
	<link rel="stylesheet" type="text/css" href="../css/shThemeDefault.css" >
	<link rel="stylesheet" type="text/css" href="../css/site.css" >

	
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->

    <link rel="shortcut icon" href="../icon.png">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="../index.html">Lense</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Get Started<b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li class="disabled"><a href="../learn.html">Learn Lense</a></li>
					<li class="disabled"><a href="../try.html">Try Lense</a></li>
					<li><a href="https://github.com/sergiotaborda/lense-lang">Download</a></li>
				</ul>
			</li>
            <li class="dropdown">
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Fundamentals<b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="../tour/tour.html">Language Tour</a></li>
					<li class="disabled"><a href="../guide.html">Programmer's Guide</a></li>
					<li><a href="../platforms.html">Target Platforms's Guide</a></li>
						<li><a href="../glossary.html">Glossary</a></li>
				</ul>
            </li>
			
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Details<b class="caret"></b></a>
				<ul class="dropdown-menu">
					<li><a href="../nullability.html">Nullability</a></li>
					<li><a href="../numbers.html">Numbers</a></li>
					<li><a href="../strings.html">Strings</a></li>
					<li><a href="../arrays.html">Arrays</a></li>
					
					<li><a href="../containerLiterals.html">Container Literals</a></li>
					<li><a href="../objects.html">Classes and Objects</a></li>
					<li><a href="../constructors.html">Constructors</a></li>
					<li><a href="../properties.html">Properties</a></li>
				
					<li><a href="../operators.html">Operators</a></li>	
				
					<li><a href="../monads.html">Monads</a></li>
					<li><a href="../concurrency.html">Concurrency</a></li>
					<li><a href="../erasure.html">Type Erasure</a></li>
					
					<li><a href="../enhancements.html">External Enhancements</a></li>
					
				</ul>
            </li>
			<li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">More<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="https://github.com/sergiotaborda/lense-lang">Source Code</a></li>
			    <li><a href="https://groups.google.com/forum/#!forum/lense-lang">Discussion Group</a></li>
				
				<li><a href="../status.html">Roadmap &amp; Status</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
	<div class="corner-ribbon top-right sticky shadow"><a href="../status.html">Exploration Stage</a></div>
    <div class="container">
	<div class="container-fluid">
		<div class="row row-offcanvas row-offcanvas-right">
			 <div class="col-xs-12 col-sm-9 col-sm-push-3">
				<p>This a simple tour of the language. At <a href="../status.html">this stage</a> some feature are not decided upon, so sintax may change and features may be added or removed.<br/>Features that may change are marked as <em>Under Consideration</em>.</p><h1>Guideline Principles</h1><p>Lense is base in some principles. These principles are used as guidelines during the language's design :</p>
<ul>
  <li><p>One Language , Many runtimes: Lense aims to be a universal language in the sense it can be executed on several different target runtime platforms that behave like the same logic platform.<br/>But this mean the plataform limits the possibilites. For example, a file system is not available for the JavaScript platform targeting browsers, since browser have no native access to file systems, but is available in the Javscript plataform running on servers. On the other hand only a web application targeting JavaScript on a browser can call a DOM API and receive events and such.<br/>Lense resolves this using modules. Some modules will only be available in some target plataforms.<br/>For more on target platforms read the <a href="../platforms.html">plataforms guide</a></p></li>
  <li><p>Everything is an object : Everything you can place in a variable is an object, and every object is an instance of a class.<br/>Even numbers and functions are objects. All classes inherit from the <code>Any</code> class and <a href="../nullability.html">there are no <em>nulls</em></a><br/>There is no explicit static scope. Hence, there is no <code>static</code> keyword. All members are objects that belong to objects. However, the <code>object</code> declaration allows to the definition of singleton objects that exist in a <em>static-like</em> context. You refer to these objects by their names as the name are unique. </p></li>
  <li><p>Modular : Modules, and not classes, are the units of deployment. All code compiled in Lense will produce a Module.<br/>Modules can be organized in packages. Classes live in packages. Modules are compiled depending on the target platform. The same module source code can produce several module archives, one for deployment in each platform. (Under revision)</p></li>
  <li><p>Strong Type System : Lense is strong typed and supports type inference, type variance and reification. Specifying types in code allows the compiler, and other tools, to reason about your intent and infer some things.However, more often than not, the compiler will infer the types and you will not have to specify them. </p></li>
  <li><p>Easy to Read : When you look at a code you wrote 1 year before is hard to remember what the code does, less alone 10 years before. Code must be simple to read. <a href="../identifiers.html">Identifiers</a> must start with a letter, followed by any combination of characters and digits. No special symbols allowed.</p></li>
  <li><p>Easy to Write : Writing must be fluent an coerent a keep to the minimum information necessary. Easy to write does not mean shorter words, or the heavy use of acronyms. It means reduction of boiler plate. Each word types is meaningfull and necessary. </p></li>
  <li><p>Expression of intension is more important that performance. Lense introduces many concepts that may not be easy to implement from a performance point of view, like Complex numbers for example. Lense conception cannot be limited by the performance restrictions because those are manly a runtime problem, and since we are trying to run the same abstractions on different environments is not possible to performatic on all of them. So abstraction and expression of intension comes first. Performance is a problem of the runtime implementation.</p></li>
</ul><h1>A basic Lense program (Under consideration)</h1><p>The most basic program is a console interaction program. The famous <em>Hello, word!</em> in Lense would look like this:</p>
<pre><code class="brush: lense ">public object MyApplication extends ConsoleApplication {

	public run (){
		val name : String = this.arguments[0];
		
		this.console.println(&quot;Hello, {{ name }}!&quot;);
	}
}
</code></pre><p>The program's entry point is an <code>Application</code> object. In this case a <code>ConsoleApplication</code>. Lense does not support static members like other languages because everything is an object.<br/>However is supports the singleton pattern out of the box. By using an <code>object</code> declaration you define an object of type, in this case, <code>ConsoleApplication</code> that has a <code>run()</code> method.<br/>The <code>run</code> method is the program's entry point.</p><p>A program must be package into a module to be runnable. Lense supports modules out of the box:</p>
<pre><code class="brush: lense ">module MyApplicationModule (1.0.0) {

	imports lense.core 1.0.0;
}
</code></pre><p>There must always exist a module in you application (you application <em>is</em> a module).<br/>A module can be executable if it contains an <code>Application</code> object. If it does not contain an <code>Application</code> oject it's library module to be used by other modules.<br/>A module can not contain more than one <code>Application</code> object.</p><p>Each module must have a name and a version. In this case the name is <em>MyApplicationModule</em> and the version is <em>1.0.0</em>. Lense understands version literals, no need to wrap the version in a string.<br/>If you need access to passed arguments you can read them from the <code>arguments</code> property in <code>Application</code>.<br/>This property holds a <code>Sequence&lt;String&gt;</code> with the parameters given in the command line. If no arguments were passed or the application is running in an environment<br/>without access to arguments (like a web browser) the sequence is empty.</p><h1>Variables and Values</h1><p>Creating variables in Lense is very similar to other languages.</p>
<pre><code class="brush: lense">var  name : String = &quot;Alice&quot;;
</code></pre><p>Lense as type inference, to the this code can be simplified to :</p>
<pre><code class="brush: lense">var  name = &quot;Alice&quot;;
</code></pre><p><em>Note</em>: For this tour we will always use the types explicitly to document and clarify what's going on, but in real code types can be omited.</p><p>Variables always contain references to objects. The variable called <em>name</em> contains a reference to a <code>String</code> object with a value of <em>Alice</em>.<br/>The reference contained in a variable can be changed further down in the code to another reference, like :</p>
<pre><code class="brush: lense">var name : String = &quot;Alice&quot;;
name = &quot;Beth&quot;;
</code></pre><p>The use of the <code>var</code> keyword defines a variable (mutable) reference declaration. Immutable references are defined with the <code>val</code> keyword.</p>
<pre><code class="brush: lense">val name : String = &quot;Alice&quot;;
</code></pre><p>Immutable values cannot be changed, so trying to do so is a compilation error.</p>
<pre><code class="brush: lense">val name : String = &quot;Alice&quot;;
name = &quot;Beth&quot;; // Compilation Error 
</code></pre><h2>Nullability</h2><p>Variables (immutable or not) must be initialized with values. Lense does not allow uninitialized variables to be used. So, this code will fail:</p>
<pre><code class="brush: lense">val  name : String;

Console.println(name); // Compilation error. Variable was not initialized.
</code></pre><p>In addition, Lense as no concept of "null reference". References always exist.<br/>This will also fail:</p>
<pre><code class="brush: lense">val name : String = null; // Compilation error. null is a reserved keyword to prevent use.

Console.println(name); 
</code></pre><p>However, Lense understands possible absent values if you use a <code>Maybe&lt;T&gt;</code> type. The <code>Maybe&lt;T&gt;</code> type is a <a href="../monads.html">monad type</a> that holds a some value or none.</p>
<pre><code class="brush: lense">val  name : Maybe&lt;String&gt; = none;  

Console.println(name); // prints &quot;none&quot;;

name = new Some(&quot;Alice&quot;); 

Console.println(name); // prints &quot;Alice&quot;;
</code></pre><p><code>Maybe</code> values are used very often in code, so Lense add some facilities to ease your writing.</p>
<pre><code class="brush: lense">val  name : String?;   // use ? shorthand notation for Maybe. Also auto-initializaed to &#39;none&#39; implictly.

Console.println(name); // prints &quot;none&quot;;

name = &quot;Alice&quot;; // implicitly promote values when assigned to a Maybe types variable.

Console.println(name); // prints &quot;Alice&quot;;
</code></pre><p>The ? sign after the <code>String?</code> type is a shorthand notation for <code>Maybe&lt;String&gt;</code>. You can use this notations with any type. The compiler will automaticlly initialize any maybe type variable to <code>none</code> unless otherwise specified. The compiler will also implicitly promote any value to a maybe on assignment.</p><h1>Fundamental types</h1><p>The Lense language has special support for the following types:</p>
<ul>
  <li>Number</li>
  <li>Binary</li>
  <li>String</li>
  <li>Boolean</li>
  <li>Range</li>
  <li>Interval</li>
  <li>Sequence (like Arrays and Lists)</li>
  <li>Associations (like Maps)</li>
  <li>Tuple</li>
  <li>Maybe</li>
</ul><p>You can initialize an object of any of these special types using a <a href="../containerLiterals.html">literal</a>. For example, 'this is a string' is a string literal, and <code>true</code> is a boolean literal.</p><h2>Numbers</h2><p>Numbers are separated in specific algebraic structures that conform to their mathematical rules.<br/>All numbers are descendent types of the <code>Number</code> class. Operations are defined for each type independently.<br/>Lense supports Natural, Integer, Real, Complex and Imaginary numbers. A byte is not a number in Lense, its a <code>Binary</code> object. </p><p>Natural is used as an indexer for sequences. It is non-negative and has big as you need. Limits for the size of collections like arrays, lists and maps are only bound by their implementation. Using a Natural to index sequences removes the necessity to check for negative indexes and as Arrays always have a upper limit and always are constructed by <a href="constructors.html">factory like constructors</a><br/>the implementation for each platform can accommodate different implementations according to maximum length demand.<br/>For more information on how <code>Natural</code> relates to index of sequences, see how <a href="arrays.html">Arrays</a> work in Lense.</p><p>Arithmetic operations are defined by <a href="operators.html">Operator Interfaces</a> so you can implement you own versions of the common operators.</p><p>For more detail on number visit the dedicated <a href="numbers.html">numbers</a> page</p><h2>Strings</h2><p>A string in Lense is a Sequence of Character. Characters are UTF-16 code points. A string literal is just a text enclosed in double quotes.</p>
<pre><code class="brush: lense">val greating : String = &quot;Hello, world&quot;;
</code></pre><p>You can interpolate values inside literal strings using <code>{{</code> and <code>}}</code> as delimiters.</p>
<pre><code class="brush: lense">val  name : String= &quot;Alice&quot;;
val  greating : String = &quot;Hello, {{ name }}&quot;;
</code></pre><p>You can concatenate strings using the <code>+</code> operator.</p>
<pre><code class="brush: lense">val name : String = &quot;Alice&quot;;
val greating : String = &quot;Hello, &quot; + name;
</code></pre><p>String are mulit-line, so you can simply right</p>
<pre><code class="brush: lense">val greating : String = &quot;Hello, 
	wold&quot;;
</code></pre><p>The line break , tab and spaces in the second line will be preserved.</p><p>If you need to use a Unicode a special character enclosing an hexadecimal natural value with <code>\{</code> and <code>}</code> delimiters.</p>
<pre><code class="brush: lense">val definePi : String = &quot;The value of \{#03C0} is the ratio between the circumference and the diameter of a circle&quot;
</code></pre><h2>Booleans</h2><p>To represent boolean values, Lense has a type named <code>Boolean</code>. Only two objects have type Boolean: the boolean literals <code>true</code> and <code>false</code>, which are both compile-time constants.<br/>Lense is strong types and only allows Boolean values and expressions where a Boolean is expected. For example, the following code will not compile:</p>
<pre><code class="brush: lense">val name : String = &quot;Alice&quot;;
if (name){  // Compilation error. Expected Boolean expression
	printName(name);
}
</code></pre><h1>Collections</h1><p>Lense offers a rich API to handle collections. All collections in Lense are <a href="../monads.html">monads</a>.<br/>All collections inherit from the <code>Assortment</code> class and are read-only and immutable by design. Mutable implementations exist.</p><h2>Sequence</h2><p>Sequences are assortments that let you assign a <code>Natural</code> index to each element. The elements can be iterated in the order of their indexes.<br/>Sequences are immutable and read-only. Sequences are fundamental in Lense and not arrays as in other languages (like Java).<br/>Lense provides a very familiar syntax for sequences:</p>
<pre><code class="brush: lense">val cities : Sequence&lt;String&gt;  = [&quot;New York&quot;, &quot;London&quot;, &quot;Paris&quot;];

val london = cities[1]; // access by a Natural index
</code></pre><h3>Arrays</h3><p>In Lense an <code>Array</code>in an implementation of <code>EditableSequence</code>s. This means you can chance the values in each position of the sequence but you cannot change the sequence's size.<br/>Arrays in Lense are fixed in size. To add a new element to the array you need to create a new array. Also keep in mind arrays in Lense are objects of the <code>Array&lt;T&gt;</code> class and not primitive types like in Java.</p>
<pre><code class="brush: lense">val cities : Array&lt;String&gt; = [&quot;New York&quot;, &quot;London&quot;, &quot;Paris&quot;];

val london = cities[1]; // access by a natural index

cities[1] = &quot;São Paulo&quot;; // position 1 now refers to &quot;São Paulo&quot; and not to &quot;London&quot; any more.
</code></pre><p>Because of Lense's <a href="../constructors.html">conversion constructors</a> you can initialize an Array with a Sequence literal.</p><h3>Lists</h3><p><code>List</code> is an implementation of <code>ResizeableSequence</code> that is both editable (like Arrays) and resizeable. This means you can add and remove elements from a list after the list is created.<br/><code>List</code> implementation is equivalent to <code>ArrayList</code> in Java.</p>
<pre><code class="brush: lense">val cities : List&lt;String&gt; = [&quot;New York&quot;, &quot;London&quot;, &quot;Paris&quot;];

cities.remove(1); // removes element at index 1, &quot;London&quot; in this example
cities.add(&quot;São Paulo&quot;); // add a new element at end of the list
</code></pre><h3>Range</h3><p>Lense supports Ranges. A Range is a special sequence of elements that has a <em>start</em> and an <em>end</em> and knows how to iterate elements from the start to the end.<br/>A Range is normally created from a Rangeable. A Rangeable defines an <code>upTo</code> method that returns a Range.</p>
<pre><code class="brush: lense">val  range Range&lt;Natural&gt; = 1.upTo(9);
</code></pre><p>This constructs a Range from 1 inclusive to 9 inclusive. Lense also supports an operator called <code>..</code> that you can use instead of <code>upTo</code>.</p>
<pre><code class="brush: lense">val range Range&lt;Natural&gt;  = 1..9;
</code></pre><p>This is usefull in interations</p>
<pre><code class="brush: lense">for (Natural n in 1..9){
  // do something
}
</code></pre><h2>Association</h2><p>Associations are like sequences, but instead of attributing a Natural index to each element, you can attribute an object to each element. This object act like a key to later retrive the stored object. Lense also provides a familiar literal for Associations. Associations, like sequences, are imutable.</p>
<pre><code class="brush: lense">val personsAndJobs : Association&lt;String, String&gt;  = { &quot;Alice&quot;: &quot;CEO&quot;, &quot;Bob&quot;:&quot;CIO&quot; , &quot;Claude&quot;:&quot;CFO&quot; };
</code></pre><p>Like Sequences, Associations are immutable and read-only.</p><h3>Dictionary</h3><p><code>Dictionary</code> is an implementation of <code>EditableAssociation</code> that allows for the edition of the values associated with keys, but does not allow the modification of the keys.</p>
<pre><code class="brush: lense">val personsAndJobs  Dictionary&lt;String, String&gt; = { &quot;Alice&quot;: &quot;CEO&quot;, &quot;Bob&quot;:&quot;CIO&quot; , &quot;Claude&quot;:&quot;CFO&quot; };

personsAndJobs.replace(&quot;Alice&quot;, &quot;CTO&quot;); // replaces the value pointed by the 
</code></pre><h3>Maps</h3><p><code>Map</code> is an implementation of <code>ResizableAssociation</code> that you can use to manipulate editable and resizeable associations. In Lense, Map implementation is similar to that of HashMap in Java.</p>
<pre><code class="brush: lense">val personsAndJobs  Map&lt;String, String&gt; = { &quot;Alice&quot;: &quot;CEO&quot;, &quot;Bob&quot;:&quot;CIO&quot; , &quot;Claude&quot;:&quot;CFO&quot; };

personsAndJobs.removeKey(&quot;Alice&quot;); // removes the key and its value.
</code></pre><h2>Tuples</h2><p>Tuples are special assortments. They are like sequences of objects in the sense each element has an index. The difference is that each element can be of a different type with no relation to the other elements (has in a sequence all elements are off the same class or inherit from it).</p>
<pre><code class="brush: lense">val  personsAndJobs : (String, Natural , Boolean) = (&quot;Alice&quot;, 42 , true);
</code></pre><p>Lense provides the abose short sintax to create tuple's types and values. the compiler will translate that notation to the following notation that you can also use.</p>
<pre><code class="brush: lense">val personsAndJobs : Tuple&lt;String, Tuple&lt;Natural , Tuple&lt;Boolean, Nothing&gt;&gt;&gt;  = (&quot;Alice&quot;, 42 , true);
</code></pre><p>If you are interested, you can read <a href="../containerLiterals.html">more on container literals</a>. </p><p>Lense understands that a variable of type X can be considered a variable of type 1-tuple of X, so 1-tuples can be assigned to variables directly and vice-versa:</p>
<pre><code class="brush: lense">val tuple1 : (String)  = (&quot;Alice&quot;); // commom pattern
val tuple1 : (String)  = &quot;Alice&quot;; // also valid
val name : String  = &quot;Alice&quot;; // commom pattern
val name : String  = (&quot;Alice&quot;); // also valid
val name : String  = tuple1; //  also valid
</code></pre><h1>Functions</h1><p>Functions allow for algorithms to be encapsulated. Normally these algorithms depend on parameters that the function declares explicitly and return a value.</p>
<pre><code class="brush: lense">	 public doSomething() : Void { 
	 	Console.print(&quot;Did something&quot;);
	 }
	 
	  square ( x : Natural) : Natural { 
		return x*x; 
	 }
</code></pre><p>Functions always return a value. <code>Void</code> is not a keyword, is an actual type. <code>Void</code> only has one instance denoted <code>()</code> (the empty tuple). All functions have an implicit return of the instance of <code>Void</code> at the end. This is correct unless the method return another type.<br/>You can explicitly write a return of the instance of <code>Void</code>.</p>
<pre><code class="brush: lense">	 public doSomething() : Void  { 
	 	Console.print(&quot;Did something&quot;);
	 	return; // implicitly returns the instance of Void.
	 };
</code></pre>
<pre><code class="brush: lense">	 public  doSomething() : Void { 
	 	Console.print(&quot;Did something&quot;);
	 	return (); // explicit returns the instance of Void.
	 };
</code></pre><p>Functions are objects of type <em>Function</em>. There is a type for each number of parameters. So <code>Function&lt;R&gt;</code> is for a function with no parameters that returns a type <code>R</code>. <code>Function&lt;R,T&gt;</code> if for a single parameter function.<br/><code>Function&lt;R,T,U&gt;</code> is for a function of two parameters, and do on ...</p>
<pre><code class="brush: lense">	 val f : Function&lt;Int, Int&gt; = x -&gt; x*x; 
	 val g : Function&lt;Int, Int, Int&gt;= (x,y) -&gt; x*y;
	 
	 Console.println(f(3));  
	 Console.println(g(3,2));
</code></pre><p>Prints</p>
<pre><code class="console">9
6
</code></pre><p>When functions are defined in the context of a class we talk about methods. Methods are functions bound to an instance of a class.<br/>Method can make calls to the <code>this</code> variable that implicitly represent the instance the function is bonded to.</p><h2>Transforming Methods into Functions (Under Consideration)</h2><p>Using reflection, methods can be converter to functions that can be invoked if the instance object is passed explicitly </p>
<pre><code class="brush: lense">	val  one : Integer= 1;

    val  minusOne: Integer = one.negative();

    // extract the underlying function
    val negativeOf : Function&lt;Number,Number&gt;  = one::negative(); // f has a parameter of type Number representing the bounded value of *negative*.

    val  alsoMinusOne : Integer = negativeOf(one);
	val  minusTwo : Integer = negativeOf(2);
</code></pre><p>Note the use of the <code>::</code> operator to detach members from object instances.<br/>You can do the same using the class instead of the instance.</p>
<pre><code class="brush: lense">    // extract the underlying function
    val negativeOf : Function&lt;Number,Number&gt; = Integer::negative(); // f has a parameter of type Number representing the bounded value of *negative*.

    val alsoMinusOne : Integer = negativeOf(one);
	val minusTwo : Integer = negativeOf(2);
</code></pre><h1>Operators</h1><p>Lense does not support operator overloading but lets you use operators like <code>+</code> and <code>*</code> in your own classes. Each operator is defined in a interface.<br/>For example , for the <code>+</code> operator is the <code>Summable&lt;A,D,S&gt;</code> interface. These special interfaces are called <em>Operator Interfaces</em> in the documentation.</p><p>Note that this interfaces do not define the result or the parameters must be of the same type. They as generic as you can get.</p><p>Another family of interfaces define algebraic structures. These structures enforce other rules (like the types all be the same) and provide properties for the underlying type.<br/>Algebraic structures help model some more abstract algebra concepts like <em>Magma</em>, <em>Group</em> , <em>Ring</em> or <em>Field</em>. </p><p>The different algebraic structures are the reason not all number types have the same operations. Integer, for example, do not have division, and so cannot for a <em>Field</em>.</p><h1>Control Flow Statements</h1><p>Lense control flow is pretty much what you would expect and are a costumed to see in other languages.</p><h2>if-then-else</h2><p>The <em>if-then-else</em> decision statement is pretty much the same as in Java , C# and other languages.</p>
<pre><code class="brush: lense">if (condition){
   // do somthing
} else if (otherCondition){
   // do this other thing
} else {
   // do something else.
}
</code></pre><p>The <code>if</code> clause demands a Boolean condition to be evaluated. The condition must be of type boolean. Any other type will throw a compilation error.<br/>You can chain and nest <em>if-then-else</em> as much as you like.</p><h2>while-do</h2><p>The <em>while-do</em> repetition structure is also pretty much the same as in Java , C# and other languages.</p>
<pre><code class="brush: lense">while (condition){
	// repeat this if condition is true
}
</code></pre><h2>for-each</h2><p>A very common task in object oriented programming is iterating over a collection of elements. Lense provides the <em>for-each</em> structure to help in this very common task.</p>
<pre><code class="brush: lense">for (val element in collection){
	// repeat this code for each element 
}
</code></pre><p>You can use <em>for-each</em> with any object that implements the <code>Iterable</code> interface.<br/>You can use type of the variable instead of var. If you use <code>var</code> the type will be infered from the collection signature.</p>
<pre><code class="brush: lense">for (String element in collection){
	// repeat this code for each element 
}
</code></pre><p>Lense does not have the traditional increment base <em>for</em> like it exist in Java or C#.</p>
<pre><code class="brush: java">// java and others
for (int i = 1; i &lt;= 9  ; i++){  // this exists in Java and C#, not in Lense
	// repeat for each i
}
</code></pre><p>Instead you can use a Progression.</p>
<pre><code class="brush: lense">for (var i in 1..9){
	// repeat for each i
}
</code></pre><h1>Exceptions</h1><p>Lense supports throwing Exceptions. An Exception is a special object. When an Exception is thrown the execution of the code stops and the method returns.<br/>You can that catch the exception with a <em>try-catch-finally</em> statement.</p>
<pre><code class="brush: lense">try {
  // do something that can throw an exception
  throw new ArithmenticException();
} catch (ArithmenticException e) {
  // do something is the exception occurred
} finally {
  // do something either if the exception occurred or not.
}
</code></pre><p>Lense does not support checked exception like Java does. </p><h1>Classes</h1><p>Lense supports classes and class inheritance to define objects and relations betweeen them.<br/>Lense also supports interfaces, object delcarations and traits (under consideration).</p><p>All Lense types suport fields, properties , methods and constructors as members.<br/>Lense also supports overloading of methods and genric types.</p><p>More on types on the <a href="objects.html">types page</a>.</p><h1>Generics</h1><p>Lense supports reified generics with variance control. </p>
<pre><code class="brush: lense">public interface Sequence&lt;out T&gt; { }

public interface Validator&lt;in T&gt; { }

public interface List&lt;T&gt; { }
</code></pre><p>Lense support co-variant types (out), contra-variant types (in) and invariant types (default) </p><h1>Modules and visibility (Under Consideration)</h1><p>Lense supports modules. Every application or library is packaged as a module. A modulue is similar to a jar file in java or a dll in .Net,<br/>but contains a little more structure.</p><p>Modules can import types from other modules and can export they own types to other modules to use.</p><p>Visibility modifies like <code>private</code>, <code>public</code> and <code>protected</code> have the same semantics an in java or C#, however there is no <em>default</em> level like in java.<br/>If visibility is not explicit , <code>private</code> is used. </p><p>A litte diference is that a type being maked as <code>public</code> adicionaly means that any other module can used it and are exported by default. If you do not want to export a classe use the <code>internal</code> visibility modifier.</p><h1>Parallelism and Concurrency (Under Consideration)</h1><p>Lense does not support creating an control of threads directly nor support the commom memory model.<br/>Instead Lense provides an actor based API to handle concurrency and parallelism. Parallelism is also ofered by special APIs lik Parallelism is supported by APIs like <code>Iterable.asParallel()</code>. </p><h1>Reflection (Under Consideration)</h1><p>Lense offer a reflection API based on the <code>Type</code> class. </p>
<pre><code class="brush: lense">   val stringType : Type = typeOf(String);
   val alsoStringType : Type = &quot;some String&quot;.getType(); 

   Console.println(&quot;String has {{ stringType.Methods.size }} methods&quot;);
</code></pre><h1>Comments</h1><p>Lense supports inline comments with <code>//</code> and multi-line comments with <code>/{</code> and <code>}/</code></p>
<pre><code class="brush: lense">/{
    this is a multi-line comment

     /{
       Multi-line comments can be nested
     }/
}/
public class Client {

     // the following line uses a single line comment to inform the role of the field
      val  name : Natural; // the name of the client       
}
</code></pre><p>As in other languages comments should be avoid by renaming your types and members with better names, but some times<br/>you will need them to explain some complex algorithm.</p>
			</div>
			<div class="col-xs-6 col-sm-3 col-sm-pull-9 sidebar-offcanvas" id="sidebar"">

<ol>
	<li>Introduction</i>
	<li><a href="status.html">Status</a></i>
	<li>Syntax and Semantics
		<ol>
			<li><a href="identifiers.html">Reserved Words</a></li>
			<li>Variables</li>
			<li>Mutability</li>
			<li><a href="nullability.html">Nullability</a></li>
			<li>Comments</li>
			<li>Generics</li>
			<li>Functions</li>
			
			<li>Fundamental Types
				
				<ul>
					<li><a href="strings.html">Strings</a></li>
					<li><a href="numbers.html">Numbers</a></li>
					<li>Ranges</li>
					<li><a href="interval.html">Intervals</a></li>
					<li><a href="arrays.html">Arrays</a></li>
					<li>Tuples</li>
					<li><a href="containerLiterals.html">Container Literals</a></li>
				</ul>
			</li>
			<li>Control Statements
				<ul>
					<li>Decision: if</li>
					<li>Loop : while</li>
					<li>Iteration : for</li>
					<li>Selection : switch</li>
				</ul>
			</li>
			
			<li><a href="objects.html">Classes and Objects</a>
				<ul>
					<li><a href="constructors.html">Constructors</a></li>
					<li><a href="properties.html">Properties</a></li>
				</ul>
			</li>
			<li>Enums</li>
			<li><a href="enhancements.html">Enhancements</a></li>
			<li>Lambdas</li>
			<li>Casting</li>
			<li><a href="operators.html">Operator Overloading</a></li>
			
		</ol>
	</li>
	<li>Compilation
		<ul>
			<li><a href="platforms.html">Platforms</a></li>
			<li><a href="erasure.html">Erasure</a></li>
		</ul>
	</li>
	<li><a href="concurrency.html">Concurrency</a>
		<ol>
			<li>Promisses</li>
			<li>Executors</li>
			<li>Actors</li>
		</ol>
	</li>

<ol>			</div>
		</div>
	</div>
	
	
		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">Lense is an open source project and a community driven effort</p>
      </div>
    </div>
    
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>
    <script>
    	SyntaxHighlighter.config.tagName = 'code';
		SyntaxHighlighter.defaults.toolbar = false;
		SyntaxHighlighter.all();
    
    </script>
  </body>
</html>